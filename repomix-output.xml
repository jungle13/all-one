This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docker-compose.yml
erp-backend/.dockerignore
erp-backend/alembic.ini
erp-backend/alembic/env.py
erp-backend/alembic/README
erp-backend/alembic/script.py.mako
erp-backend/app/core/config.py
erp-backend/app/core/db.py
erp-backend/app/core/security.py
erp-backend/app/main.py
erp-backend/app/modules/raffles/.dockerignore
erp-backend/app/modules/raffles/.gitignore
erp-backend/app/modules/raffles/app/api/dependencies.py
erp-backend/app/modules/raffles/app/api/v1/__init__.py
erp-backend/app/modules/raffles/app/api/v1/auth.py
erp-backend/app/modules/raffles/app/api/v1/raffles.py
erp-backend/app/modules/raffles/app/api/v1/tickets.py
erp-backend/app/modules/raffles/app/api/v1/uploads.py
erp-backend/app/modules/raffles/app/core/config.py
erp-backend/app/modules/raffles/app/core/security.py
erp-backend/app/modules/raffles/app/db/base.py
erp-backend/app/modules/raffles/app/db/database.py
erp-backend/app/modules/raffles/app/db/models.py
erp-backend/app/modules/raffles/app/db/repositories/raffle.py
erp-backend/app/modules/raffles/app/db/repositories/ticket.py
erp-backend/app/modules/raffles/app/models/__init__.py
erp-backend/app/modules/raffles/app/models/user.py
erp-backend/app/modules/raffles/app/schemas/raffle.py
erp-backend/app/modules/raffles/app/schemas/ticket.py
erp-backend/app/modules/raffles/app/schemas/user.py
erp-backend/app/modules/raffles/app/services/auth.py
erp-backend/app/modules/raffles/app/services/generate_image.py
erp-backend/app/modules/raffles/app/services/raffle_service.py
erp-backend/app/modules/raffles/app/services/send_whatsapp_message.py
erp-backend/app/modules/raffles/app/services/ticket_service.py
erp-backend/app/modules/raffles/app/utils/auth.py
erp-backend/app/modules/raffles/app/utils/cleanup.py
erp-backend/app/modules/raffles/app/utils/test_data.py
erp-backend/app/modules/raffles/create_first_user.py
erp-backend/app/modules/raffles/Dockerfile
erp-backend/app/modules/raffles/main.py
erp-backend/app/modules/raffles/package.json
erp-backend/app/modules/raffles/pyproject.toml
erp-backend/app/modules/raffles/requirements.txt
erp-backend/app/modules/raffles/scripts/start.sh
erp-backend/app/modules/users/api.py
erp-backend/app/modules/users/models.py
erp-backend/app/modules/users/schemas.py
erp-backend/app/modules/users/services.py
erp-backend/Dockerfile
erp-backend/pyproject.toml
erp-frontend/.dockerignore
erp-frontend/.gitignore
erp-frontend/Dockerfile
erp-frontend/index.html
erp-frontend/package.json
erp-frontend/src/App.jsx
erp-frontend/src/core/api/apiClient.js
erp-frontend/src/core/components/layout/MainLayout.jsx
erp-frontend/src/core/components/SubscriberTable.jsx
erp-frontend/src/core/components/ui/KpiCard.jsx
erp-frontend/src/core/components/ui/PageHeader.jsx
erp-frontend/src/core/contexts/AuthContext.jsx
erp-frontend/src/core/contexts/ThemeModeContext.jsx
erp-frontend/src/core/navigation/menuConfig.js
erp-frontend/src/main.jsx
erp-frontend/src/modules/admin/components/SubscriberTable.jsx
erp-frontend/src/modules/admin/pages/SubscriberListPage.jsx
erp-frontend/src/modules/auth/pages/LoginPage.jsx
erp-frontend/src/modules/dashboard/pages/Dashboard.jsx
erp-frontend/src/routes/index.jsx
erp-frontend/src/routes/ProtectedRoute.jsx
erp-frontend/src/theme/index.js
erp-frontend/src/theme/theme.js
erp-frontend/vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="erp-frontend/src/core/api/apiClient.js">
import axios from 'axios';

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1',
  headers: { 'Content-Type': 'application/json' }
});

apiClient.interceptors.request.use((config) => {
  const raw = localStorage.getItem('user');
  if (raw) {
    const { token } = JSON.parse(raw) || {};
    if (token) config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default apiClient;
</file>

<file path="erp-frontend/src/core/components/SubscriberTable.jsx">
// PATH: erp-frontend/src/modules/admin/components/SubscriberTable.jsx
import * as React from 'react';
import { Box, Button, Stack } from '@mui/material';
import { DataGrid, GridActionsCellItem, GridToolbarQuickFilter } from '@mui/x-data-grid';
import EditRoundedIcon from '@mui/icons-material/EditRounded';
import DeleteOutlineRoundedIcon from '@mui/icons-material/DeleteOutlineRounded';
import AddRoundedIcon from '@mui/icons-material/AddRounded';

/**
 * Tabla de Suscriptores (única y robusta):
 * - Acepta `rows` (preferido) o `data` (compatibilidad).
 * - Si recibe indefinidos, usa [] y NO rompe.
 */
export default function SubscriberTable({ rows, data, onAdd, onEdit, onDelete }) {
  const safeRows = React.useMemo(() => {
    if (Array.isArray(rows)) return rows;
    if (Array.isArray(data)) return data;
    return [];
  }, [rows, data]);

  const columns = React.useMemo(() => [
    { field: 'name', headerName: 'Nombre', flex: 1, minWidth: 180 },
    { field: 'email', headerName: 'Correo', flex: 1, minWidth: 220 },
    { field: 'plan', headerName: 'Plan', width: 140, valueGetter: (v, r) => r?.plan ?? '—' },
    { field: 'status', headerName: 'Estado', width: 140, valueGetter: (v, r) => r?.status ?? '—' },
    {
      field: 'actions',
      type: 'actions',
      headerName: 'Acciones',
      width: 120,
      getActions: (params) => [
        <GridActionsCellItem
          key="edit"
          icon={<EditRoundedIcon />}
          label="Editar"
          onClick={() => onEdit?.(params.row)}
        />,
        <GridActionsCellItem
          key="delete"
          icon={<DeleteOutlineRoundedIcon />}
          label="Eliminar"
          onClick={() => onDelete?.(params.row)}
        />,
      ],
    },
  ], [onEdit, onDelete]);

  return (
    <Box sx={{ height: 520, width: '100%' }}>
      <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 1 }}>
        <Button onClick={onAdd} variant="contained" startIcon={<AddRoundedIcon />}>
          Nuevo suscriptor
        </Button>
        <GridToolbarQuickFilter sx={{ '& input': { minWidth: 260 } }} />
      </Stack>

      <DataGrid
        rows={safeRows}
        getRowId={(r) => r.id ?? r._id ?? `${r.email}-${r.name}`} // fallback por si falta id
        columns={columns}
        disableRowSelectionOnClick
        density="comfortable"
        pageSizeOptions={[5, 10]}
        initialState={{ pagination: { paginationModel: { pageSize: 5 } } }}
        sx={{
          border: 'none',
          '& .MuiDataGrid-columnHeaders': {
            borderBottom: (t) => `1px solid ${t.palette.divider}`,
          },
          height: 468,
        }}
      />
    </Box>
  );
}
</file>

<file path="erp-frontend/src/core/contexts/ThemeModeContext.jsx">
// PATH: erp-frontend/src/core/contexts/ThemeModeContext.jsx
import React, { createContext, useContext, useMemo, useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { getAppTheme } from '../../theme';

const ThemeModeContext = createContext({ mode: 'dark', toggleMode: () => {} });

export function ThemeModeProvider({ children }) {
  const [mode, setMode] = useState(() => {
    const saved = localStorage.getItem('themeMode');
    return saved === 'light' || saved === 'dark' ? saved : 'dark';
  });

  const toggleMode = () => {
    setMode((m) => {
      const next = m === 'dark' ? 'light' : 'dark';
      localStorage.setItem('themeMode', next);
      return next;
    });
  };

  const theme = useMemo(() => getAppTheme(mode), [mode]);

  return (
    <ThemeModeContext.Provider value={{ mode, toggleMode }}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        {children}
      </ThemeProvider>
    </ThemeModeContext.Provider>
  );
}

export const useThemeMode = () => useContext(ThemeModeContext);
export default ThemeModeContext;
</file>

<file path="erp-frontend/src/core/navigation/menuConfig.js">
import DashboardRoundedIcon from '@mui/icons-material/DashboardRounded';
import PeopleAltRoundedIcon from '@mui/icons-material/PeopleAltRounded';

export const ROLES = {
  ADMIN: 'admin',
  MANAGER: 'manager',
  VIEWER: 'viewer',
};

/**
 * Menú centralizado con íconos y permisos.
 * - El PRIMER ítem es "Subscriptores", como pediste.
 * - Usa `allowedRoles` para controlar visibilidad.
 */
export const menuItems = [
  {
    id: 'subscribers',
    label: 'Subscriptores',
    path: '/subscribers',
    icon: PeopleAltRoundedIcon,
    allowedRoles: [ROLES.ADMIN, ROLES.MANAGER],
  },
  {
    id: 'dashboard',
    label: 'Dashboard',
    path: '/dashboard',
    icon: DashboardRoundedIcon,
    allowedRoles: [ROLES.ADMIN, ROLES.MANAGER, ROLES.VIEWER],
  },
];

export function getMenuForRole(role) {
  return menuItems.filter((item) => !item.allowedRoles || item.allowedRoles.includes(role));
}
</file>

<file path="erp-backend/.dockerignore">

</file>

<file path="erp-backend/alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .


# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.



[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# hooks = ruff
# ruff.type = module
# ruff.module = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Alternatively, use the exec runner to execute a binary found on your PATH
# hooks = ruff
# ruff.type = exec
# ruff.executable = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="erp-backend/alembic/env.py">
import sys
from pathlib import Path

from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Add the project root to the Python path
sys.path.append(r"C:\dev\erp-backend")


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
# if config.config_file_name is not None:
#     fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
# Import your app's models here
from app.core.db import Base
from app.modules.users import models as user_models
from app.modules.raffles import models as raffle_models
# from app.modules.inventory import models as inventory_models # Uncomment when you have models

target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.
# from app.core.config import settings


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = "postgresql://user:password@localhost/db?client_encoding=utf8"
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    from app.core.db import engine
    connectable = engine

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="erp-backend/alembic/README">
Generic single-database configuration.
</file>

<file path="erp-backend/alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, Sequence[str], None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="erp-backend/app/core/config.py">
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "postgresql://user:password@localhost/db?client_encoding=utf8"
    SECRET_KEY: str = "your-secret-key"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    class Config:
        env_file = ".env"

settings = Settings()
</file>

<file path="erp-backend/app/core/db.py">
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from app.core.config import settings

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
</file>

<file path="erp-backend/app/core/security.py">

</file>

<file path="erp-backend/app/main.py">
# erp-backend/app/main.py (Versión Corregida)

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
# Ajuste de importaciones para la nueva estructura
from app.modules.users.api import router as users_router
from app.modules.raffles.app.api.v1 import router as raffles_router
# En el futuro, añadirá más routers aquí:
# from app.modules.inventory.api import router as inventory_router

app = FastAPI(
    title="ERP System API",
    description="API para el sistema ERP modular.",
    version="1.0.0"
)

# Configuración de CORS (se mantiene igual)
origins = [
    "http://localhost",
    "http://localhost:3000",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Inclusión de los routers modulares
app.include_router(users_router, prefix="/api/v1/users", tags=["Users & Auth"])
app.include_router(raffles_router, prefix="/api/v1/raffles", tags=["Raffles"])
# En el futuro, registrará los nuevos módulos aquí:
# app.include_router(inventory_router, prefix="/api/v1/inventory", tags=["Inventory"])

@app.get("/")
def read_root():
    return {"message": "Welcome to the ERP API"}
</file>

<file path="erp-backend/app/modules/raffles/.dockerignore">
# raffle-backend/.dockerignore


# Ignorar archivos de configuración de Docker y Git
Dockerfile
.dockerignore
.git
.gitignore

# Ignorar entornos virtuales de Python
venv/
venv-raffle-bk/
.venv/

# Ignorar caché de Python
__pycache__/
*.pyc
*.pyo
*.pyd

# Ignorar archivos de entorno local
.env
</file>

<file path="erp-backend/app/modules/raffles/.gitignore">
# Ignore Python virtual environment
venv-raffle-bk/
raffle-bk/

# Ignore Python cache files
__pycache__/
*.pyc
*.pyo
*.pyd

# Ignore environment variables
.env

# Ignore IDE and editor files
.vscode/
.idea/
</file>

<file path="erp-backend/app/modules/raffles/app/api/dependencies.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


def get_token_header(token: str = Depends(oauth2_scheme)):
    # Replace this with your actual token verification logic
    if token != "secret-token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )
    return token
</file>

<file path="erp-backend/app/modules/raffles/app/api/v1/__init__.py">
from fastapi import APIRouter
from .auth import router as auth_router
from .raffles import router as raffles_router
from .tickets import router as ticket_router

router = APIRouter(prefix="/api/v1")
router.include_router(auth_router)
router.include_router(raffles_router)
router.include_router(ticket_router)
</file>

<file path="erp-backend/app/modules/raffles/app/api/v1/auth.py">
# raffle-backend/app/api/v1/auth.py

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.database import get_db
from app.core.security import authenticate_user, create_access_token
# CAMBIO: Se importan los esquemas y servicios para el registro
from app.schemas.user import UserCreate, User
from app.modules.raffles.app.services.auth import create_user_service

router = APIRouter(prefix="/auth", tags=["Auth"])

# --- ENDPOINT DE LOGIN (Sin cambios) ---
@router.post("/token", summary="Create access token for user")
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    user = await authenticate_user(
        db=db, username=form_data.username, password=form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(
        data={"sub": user.username}
    )
    return {"access_token": access_token, "token_type": "bearer"}


# --- ✅ ENDPOINT DE REGISTRO (AÑADIDO) ---
@router.post("/register", response_model=User, status_code=status.HTTP_201_CREATED, summary="Register a new user")
async def register_user(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db)
):
    """
    Registra un nuevo usuario en el sistema.
    """
    try:
        new_user = await create_user_service(db, user_data)
        return new_user
    except ValueError as ve:
        # Captura el error si el usuario ya existe
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(ve))
    except Exception:
        # Captura cualquier otro error inesperado
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Error al registrar el usuario.")
</file>

<file path="erp-backend/app/modules/raffles/app/api/v1/raffles.py">
# raffle-backend/app/api/v1/raffles.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.database import get_db
from app.core.security import get_current_user
from app.db.models import User
# --- LÍNEA MODIFICADA ---
# Se importan todos los esquemas y servicios necesarios
from app.schemas.raffle import RaffleCreateRequest, RaffleListResponse, RaffleUpdateRequest, RaffleResponse
from app.services.raffle_service import create_raffle_service, list_raffles_service, update_raffle_service, get_raffle_service, check_number_availability_service, get_random_available_numbers_service, _build_raffle_response
from app.modules.raffles.app.schemas.raffle import RaffleDetailResponse
# -------------------------

router = APIRouter(prefix="/raffle", tags=["Raffles"])

# --- ENDPOINT PARA CREAR UNA NUEVA RIFA ---
# Este endpoint permite a los usuarios crear una nueva rifa.
# Utiliza el servicio para manejar la lógica de negocio y devuelve la rifa creada.
@router.post("/create", response_model=RaffleResponse, status_code=status.HTTP_201_CREATED)
async def create_raffle(
    data: RaffleCreateRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    try:
        # 1. El servicio crea la rifa y devuelve el objeto ORM
        new_raffle_orm = await create_raffle_service(data, db, current_user)
    
        # --- AJUSTE CLAVE ---
        # 2. Construimos la respuesta formateada usando la función auxiliar.
        #    Para una rifa nueva, las estadísticas son siempre 0.
        formatted_response = _build_raffle_response(
            raffle=new_raffle_orm,
            tickets_sold=0,
            participants=0
        )
        
        # 3. Devolvemos la respuesta ya formateada y completa
        return formatted_response
        
    except ValueError as ve:
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating raffle: {str(e)}")


@router.get("/", response_model=RaffleListResponse)
async def list_raffles(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    try:
        raffles = await list_raffles_service(db)
        return {"raffles": raffles}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error listing raffles: {str(e)}")

# --- ENDPOINT PARA OBTENER DETALLES DE UNA RIFA ---
# Este endpoint permite obtener los detalles de una rifa específica por su ID.
# Devuelve un objeto RaffleDetailResponse con toda la información relevante.
@router.get("/{raffle_id}", response_model=RaffleDetailResponse)
async def get_raffle(
    raffle_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    try:
        raffle = await get_raffle_service(raffle_id, db)
        return raffle
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting raffle: {str(e)}")
    
# --- ENDPOINT DE ACTUALIZACIÓN CORREGIDO Y SIMPLIFICADO ---
@router.put("/{raffle_id}", response_model=RaffleDetailResponse)
async def update_raffle(
    raffle_id: str,
    raffle_data: RaffleUpdateRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Actualiza una rifa existente. Devuelve la rifa actualizada.
    """
    try:
        # El servicio ya devuelve el objeto Raffle actualizado y compatible
        updated_raffle_orm = await update_raffle_service(raffle_id, raffle_data, db)
        
        # FastAPI y Pydantic se encargarán de convertir el objeto ORM a la respuesta JSON
        return updated_raffle_orm
        
    except ValueError as e:
        # Si la rifa no se encuentra o hay un error de validación, devuelve 400 o 404
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        # Para cualquier otro error inesperado
        raise HTTPException(status_code=500, detail=f"Error updating raffle: {str(e)}")
    

# --- ENDPOINT PARA VERIFICAR DISPONIBILIDAD DE NÚMERO ---
# Este endpoint permite verificar si un número específico está disponible para una rifa.
# Devuelve 'true' si el número está disponible, 'false' si está ocupado o excluido.
@router.get("/{raffle_id}/check-number/{number_str}", summary="Check if a number is available")
async def check_number_availability(
    raffle_id: str,
    number_str: str,
    db: AsyncSession = Depends(get_db),
    # La protección con 'get_current_user' es opcional. Si la dejas, solo usuarios
    # logueados podrán verificar números. Si la quitas, será una consulta pública.
    current_user: User = Depends(get_current_user) 
):
    """
    Verifica si un número específico está disponible para una rifa dada.
    Devuelve 'true' si está disponible, 'false' si está ocupado o excluido.
    """
    try:
        # 1. Llama al servicio que contiene la lógica de negocio
        is_available = await check_number_availability_service(raffle_id, number_str, db)
        
        # 2. Devuelve la respuesta en formato JSON
        return {"is_available": is_available}

    except Exception as e:
        # 3. Maneja cualquier error inesperado
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
            detail=f"Error al verificar la disponibilidad del número: {str(e)}"
        )
    

# --- ENDPOINT PARA OBTENER NÚMEROS ALEATORIOS DISPONIBLES ---
# Este endpoint genera y devuelve una lista de N números aleatorios disponibles para una rifa.
# Utiliza el servicio para obtener los números y maneja errores comunes.
@router.get("/{raffle_id}/random-numbers/{count}", summary="Get a list of random available numbers")
async def get_random_available_numbers(
    raffle_id: str,
    count: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Genera y devuelve una lista de N (`count`) números aleatorios disponibles para una rifa.
    """
    try:
        numbers = await get_random_available_numbers_service(raffle_id, count, db)
        return {"numbers": numbers}
    except ValueError as ve:
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
</file>

<file path="erp-backend/app/modules/raffles/app/api/v1/tickets.py">
# raffle-backend/app/api/v1/tickets.py

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks, UploadFile, File
from fastapi.responses import FileResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, cast, Date # Se añaden cast y Date
from sqlalchemy.orm import selectinload
from typing import List

from app.db.database import get_db
from app.core.security import get_current_user
from app.db.models import User, Ticket
from app.schemas.ticket import (
    TicketInfo,
    TicketListResponse,
    TicketCreateRequest, 
)
# Se importan los servicios simplificados
from app.services.ticket_service import (
    list_tickets_service,
    cancel_ticket_service,
    get_ticket_by_id_service,
    create_ticket_service,
    send_purchase_notification,
    confirm_payment_service,
)
from app.services.generate_image import generate_raffle_image
from app.modules.raffles.app.utils.cleanup import cleanup_temp_file
import tempfile
import os
import logging

from datetime import date

import shutil

router = APIRouter(prefix="/tickets", tags=["Tickets"])

# --- ENDPOINT DE CANCELACIÓN ÚNICO Y SIMPLIFICADO ---
# Este endpoint cancela un tiquete y libera sus números asociados.
# CAMBIO: Se usa un servicio para manejar la lógica de cancelación.
# CAMBIO: Se maneja la transacción de forma asíncrona.
@router.delete("/{ticket_id}/cancel", status_code=status.HTTP_200_OK, summary="Cancel a ticket and release its numbers")
async def cancel_ticket(
    ticket_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    logging.info(f"Petición recibida en DELETE /tickets/{ticket_id}/cancel por el usuario '{current_user.username}'.")
    try:
        await cancel_ticket_service(ticket_id, db)
        logging.info(f"Tiquete {ticket_id} cancelado exitosamente.")
        return {"success": True, "message": f"Ticket {ticket_id} has been cancelled."}
    except ValueError as ve:
        logging.warning(f"Error 404 al cancelar tiquete {ticket_id}: {ve}")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(ve))
    except Exception as e:
        logging.error(f"Error 500 inesperado al cancelar tiquete {ticket_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"An unexpected error occurred: {str(e)}")


@router.patch("/{ticket_id}/confirm-payment", status_code=status.HTTP_200_OK, summary="Confirm the payment of a pending ticket")
async def confirm_payment(
    ticket_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    logging.info(f"Petición recibida en PATCH /tickets/{ticket_id}/confirm-payment por el usuario '{current_user.username}'.")
    try:
        await confirm_payment_service(ticket_id, db)
        logging.info(f"Pago del tiquete {ticket_id} confirmado exitosamente.")
        return {"success": True, "message": f"Payment for ticket {ticket_id} has been confirmed."}
    except ValueError as ve:
        logging.warning(f"Error 404/400 al confirmar pago del tiquete {ticket_id}: {ve}")
        # Puede ser 404 si no se encuentra, o 400 si el estado no es pending.
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(ve))
    except Exception as e:
        logging.error(f"Error 500 inesperado al confirmar pago del tiquete {ticket_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"An unexpected error occurred: {str(e)}")


@router.get("/", response_model=TicketListResponse, summary="List all tickets")
async def list_tickets(db: AsyncSession = Depends(get_db), current_user: User = Depends(get_current_user)):
    logging.info(f"Petición recibida en GET /tickets/ por el usuario '{current_user.username}'.")
    try:
        tickets = await list_tickets_service(db)
        logging.info(f"Devolviendo {len(tickets)} tiquetes.")
        return {"tickets": tickets}
    except Exception as e:
        logging.error(f"Error 500 inesperado al listar tiquetes: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error listing tickets: {str(e)}")


@router.get("/{ticket_id}", response_model=TicketInfo, summary="Get a single ticket by ID")
async def get_ticket(
    ticket_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    logging.info(f"Petición recibida en GET /tickets/{ticket_id} por el usuario '{current_user.username}'.")
    try:
        ticket = await get_ticket_by_id_service(ticket_id, db)
        if not ticket:
            logging.warning(f"Tiquete {ticket_id} no encontrado.")
            raise HTTPException(status_code=404, detail="Ticket not found")
        logging.info(f"Tiquete {ticket_id} encontrado y devuelto.")
        return ticket
    except Exception as e:
        logging.error(f"Error 500 inesperado al obtener tiquete {ticket_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error getting ticket: {str(e)}")


@router.post("/", response_model=TicketInfo, status_code=status.HTTP_201_CREATED)
async def create_ticket(
    data: TicketCreateRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Crea un nuevo tiquete pagado.
    """
    # ---  Log para ver exactamente qué datos llegan del frontend ---
    logging.info(f"Petición recibida en POST /tickets/ por el usuario '{current_user.username}'.")
    logging.info(f"Datos recibidos del frontend: {data.model_dump_json(indent=2)}")

    try:
        new_ticket_orm = await create_ticket_service(data, db, current_user)

        await db.refresh(new_ticket_orm, ['raffle'])

        if new_ticket_orm.status == 'paid':
            logging.info(f"Añadiendo tarea de fondo para enviar notificación de WhatsApp al tiquete {new_ticket_orm.id}.")
            background_tasks.add_task(
                send_purchase_notification, 
                db, # Se pasa la sesión a la tarea de fondo
                new_ticket_orm.phone, 
                new_ticket_orm.name, 
                new_ticket_orm.raffle_id,
                new_ticket_orm.id
            )

        raffle = new_ticket_orm.raffle
        formatted_response = TicketInfo(
            id=new_ticket_orm.id,
            name=new_ticket_orm.name,
            phone=new_ticket_orm.phone,
            raffle_id=new_ticket_orm.raffle_id,
            status=new_ticket_orm.status,
            responsible=new_ticket_orm.user.username if new_ticket_orm.user else None,
            created_at=new_ticket_orm.created_at,
            updated_at=new_ticket_orm.updated_at,
            payment_type=new_ticket_orm.payment_type,
            payment_date=new_ticket_orm.payment_date,
            payment_proof_url=new_ticket_orm.payment_proof_url,
            numbers=[n.number for n in new_ticket_orm.numbers],
            number_ids=[n.id for n in new_ticket_orm.numbers],
            raffle_name=raffle.name,
            raffle_status=raffle.status,
            raffle_short_id=raffle.short_id,
            raffle_end_date=raffle.end_date,
            raffle_price=raffle.price
        )
        
        logging.info(f"Tiquete {formatted_response.id} creado exitosamente. Enviando respuesta al frontend.")
        return formatted_response

    except ValueError as ve:
        logging.warning(f"Error de validación (400) al crear tiquete: {ve}")
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        logging.error(f"Error inesperado (500) al crear tiquete: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error al crear el tiquete: {str(e)}")


# --- ENDPOINT PARA GENERAR IMAGEN DEL TIQUETE ---
# CAMBIO: Se crea un endpoint para generar una imagen del tiquete.
# CAMBIO: Se usa una función de generación de imagen y se maneja la limpieza del archivo temporal.
# CAMBIO: Se devuelve la imagen generada como FileResponse.
@router.get("/{ticket_id}/image", summary="Genera una imagen para un tiquete específico")
async def get_ticket_image(
    ticket_id: str,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db)
):
    """
    Obtiene los datos de un tiquete y su rifa asociada para generar una imagen
    visual que sirve como comprobante para el comprador.
    """
    temp_path = None
    try:
        # La consulta a la base de datos ya es eficiente y está bien
        query = (
            select(Ticket)
            .options(selectinload(Ticket.raffle), selectinload(Ticket.numbers))
            .where(Ticket.id == ticket_id)
        )
        result = await db.execute(query)
        ticket = result.scalars().first()

        if not ticket:
            raise HTTPException(status_code=404, detail="Ticket not found")

        # --- DICCIONARIO AJUSTADO CON LA INFORMACIÓN COMPLETA ---
        ticket_data_for_image = {
            "ticket_id": ticket.id,
            "buyer_name": ticket.name,
            "raffle_name": ticket.raffle.name,
            
            # Ajuste: Usamos payment_date para mayor precisión y lo formateamos.
            "purchase_date": ticket.payment_date.strftime("%d de %B de %Y") if ticket.payment_date else "N/A",
            
            # Nuevo: Añadimos la fecha del sorteo, también formateada.
            "draw_date": ticket.raffle.end_date.strftime("%d de %B de %Y") if ticket.raffle.end_date else "Por definir",

            # Ajuste: El total pagado es el precio de la rifa.
            "total_price": ticket.raffle.price,

            # Esto ya estaba correcto.
            "numbers": [n.number for n in ticket.numbers]
        }
        # --- FIN DE LOS AJUSTES ---

        # El resto de la función para generar el archivo y devolverlo es correcta.
        img = generate_raffle_image(ticket_data_for_image)
        
        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as temp_file:
            temp_path = temp_file.name
            img.save(temp_path, "JPEG", quality=95)
        
        background_tasks.add_task(cleanup_temp_file, temp_path)
        
        return FileResponse(
            temp_path,
            media_type="image/jpeg",
            filename=f"Rifa_{ticket.raffle.name.replace(' ', '_')}_Ticket_{ticket.id[:8]}.jpg"
        )
        
    except Exception as e:
        # El manejo de errores y limpieza de archivos temporales es correcto.
        if temp_path and os.path.exists(temp_path):
            cleanup_temp_file(temp_path)
        # Es buena idea loggear el error real para debugging
        # logging.error(f"Error al generar imagen para ticket {ticket_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Error interno al generar la imagen: {str(e)}")
    

# --- NUEVO ENDPOINT PARA SUBIR COMPROBANTE ---
@router.patch("/{ticket_id}/proof", response_model=TicketInfo, summary="Upload a payment proof for a ticket")
async def upload_payment_proof(
    ticket_id: str,
    proof_file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Sube un archivo de comprobante de pago para un tiquete y actualiza su URL.
    """
    ticket = await db.get(Ticket, ticket_id)
    if not ticket:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Ticket not found")

    # Lógica de guardado de archivo (simplificada para guardar localmente)
    # En producción, esto debería subir a un servicio como S3, Cloudinary, etc.
    file_extension = proof_file.filename.split('.')[-1]
    if file_extension.lower() not in ['jpg', 'jpeg', 'png']:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid file type. Only JPG and PNG are allowed.")
        
    file_path = f"uploads/proofs/{ticket_id}_{proof_file.filename}"
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(proof_file.file, buffer)
        
    # La URL sería la ruta relativa para acceder al archivo desde el frontend
    # Asegúrate de que la carpeta 'uploads' sea servida estáticamente por tu servidor
    ticket.payment_proof_url = f"/{file_path}"
    
    await db.commit()
    await db.refresh(ticket)
    
    # Reutiliza el servicio existente para devolver la información completa del tiquete
    return await get_ticket_by_id_service(ticket_id, db)

# --- NUEVO ENDPOINT PARA ELIMINAR COMPROBANTE ---
@router.delete("/{ticket_id}/proof", response_model=TicketInfo, summary="Delete the payment proof for a ticket")
async def delete_payment_proof(
    ticket_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Elimina la URL del comprobante de pago de un tiquete.
    """
    ticket = await db.get(Ticket, ticket_id)
    if not ticket:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Ticket not found")

    # Aquí también deberías eliminar el archivo físico del servidor
    # if ticket.payment_proof_url and os.path.exists(ticket.payment_proof_url.strip('/')):
    #     os.remove(ticket.payment_proof_url.strip('/'))

    ticket.payment_proof_url = None
    await db.commit()
    await db.refresh(ticket)

    return await get_ticket_by_id_service(ticket_id, db)


# --- ENDPOINT PARA DATOS DEL DASHBOARD (VERSIÓN CORREGIDA) ---
@router.get("/sales/monthly_summary", summary="Get sales summary for the current month by user")
async def get_monthly_sales_summary(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Devuelve un resumen de los tiquetes 'paid' vendidos en el mes actual,
    agrupados por día de PAGO y por vendedor (usuario).
    """
    today = date.today()
    start_of_month = today.replace(day=1)

    # --- CONSULTA AJUSTADA ---
    # Ahora se selecciona, agrupa y filtra usando 'Ticket.payment_date'.
    # Como 'payment_date' ya es de tipo Date, no se necesita el 'cast'.
    query = (
        select(
            Ticket.payment_date.label('sale_date'),
            User.username.label('seller'),
            func.count(Ticket.id).label('tickets_sold')
        )
        .join(User, Ticket.user_id == User.id)
        .where(
            Ticket.status == 'paid',
            Ticket.payment_date != None,  # Se añade filtro para evitar fechas nulas
            Ticket.payment_date >= start_of_month
        )
        .group_by(
            Ticket.payment_date,
            User.username
        )
        .order_by(Ticket.payment_date)
    )
    # --- FIN DEL AJUSTE ---

    result = await db.execute(query)
    sales_data = [row._asdict() for row in result.all()]
    
    return sales_data
</file>

<file path="erp-backend/app/modules/raffles/app/api/v1/uploads.py">
# raffle-backend/app/api/v1/uploads.py
import os
import shutil
import uuid
from fastapi import APIRouter, File, UploadFile, HTTPException, status

router = APIRouter(prefix="/uploads", tags=["Uploads"])

# Crea el directorio si no existe
os.makedirs("uploads/proofs", exist_ok=True)

@router.post("/proof", summary="Upload a generic proof file")
async def upload_generic_proof(upload_file: UploadFile = File(...)):
    """
    Recibe un archivo, lo guarda con un nombre único y devuelve su URL de acceso.
    """
    file_extension = upload_file.filename.split('.')[-1]
    if file_extension.lower() not in ['jpg', 'jpeg', 'png']:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, 
            detail="Tipo de archivo inválido. Solo se permiten JPG y PNG."
        )
        
    unique_filename = f"{uuid.uuid4()}.{file_extension}"
    file_path = f"uploads/proofs/{unique_filename}"
    
    try:
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(upload_file.file, buffer)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
            detail=f"No se pudo guardar el archivo: {e}"
        )
    
    # Devuelve la URL relativa que el frontend usará para acceder al archivo
    return {"url": f"/{file_path}"}
</file>

<file path="erp-backend/app/modules/raffles/app/core/config.py">
from pydantic_settings import BaseSettings
from pydantic import PostgresDsn, validator
from typing import Optional, Dict, Any
import os


class Settings(BaseSettings):
    # Project Metadata
    PROJECT_NAME: str = "Raffle API - Jungle One"
    API_V1_STR: str = "/api/v1"

    # Database Configuration
    #DATABASE_URL: str = "postgresql+asyncpg://postgres:1234@localhost:5432/raffle"
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql+asyncpg://postgres:1234@localhost:5432/raffle")
    # ASYNC_DATABASE_URL: Optional[str] = None

    # @validator("ASYNC_DATABASE_URL", pre=True)
    # def assemble_async_db_url(cls, v: Optional[str], values: Dict[str, Any]) -> Any:
    #     if isinstance(v, str):
    #         return v
    #     return str(values.get("DATABASE_URL")).replace(
    #         "postgresql", "postgresql+asyncpg"
    #     )

    # Security
    SECRET_KEY: str = "your-very-secret-key-here"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 1 week
    ALGORITHM: str = "HS256"

    # CORS
    BACKEND_CORS_ORIGINS: str = "http://localhost:3000"

    class Config:
        case_sensitive = True
        env_file = ".env"


settings = Settings()
</file>

<file path="erp-backend/app/modules/raffles/app/core/security.py">
from datetime import datetime, timedelta
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext # <-- AÑADIDO
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession

# NUEVO: Importaciones necesarias para la BD y la configuración central
from app.core.config import settings
from app.db.database import get_db
from app.db.models import User

# --- CONFIGURACIÓN DE PASSLIB ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica una contraseña plana contra su hash."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Genera el hash de una contraseña."""
    return pwd_context.hash(password)
# ---------------------------------

# La URL del token ahora se construye con la ruta de la API desde la configuración
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")


# MODIFICADO: La función ahora es asíncrona y consulta la BD real
async def get_user(db: AsyncSession, username: str) -> Optional[User]:
    """
    Obtiene un usuario de la base de datos por su nombre de usuario.
    """
    result = await db.execute(select(User).where(User.username == username))
    return result.scalars().first()


# MODIFICADO: Ahora es asíncrona para poder llamar a get_user
async def authenticate_user(db: AsyncSession, username: str, password: str) -> Optional[User]:
    """
    Autentica un usuario. Si es exitoso, devuelve el objeto User.
    """
    user = await get_user(db, username)
    if not user or not verify_password(password, user.hashed_password):
        return None  # Se devuelve None en lugar de False para más claridad
    return user


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Crea un nuevo token de acceso.
    """
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        # Usamos el valor de la configuración
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    # Usamos los valores de la configuración
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


# MODIFICADO: Ahora depende de la sesión de la BD y consulta la BD real
async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> User:
    """
    Decodifica el token JWT para obtener el usuario actual.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # Usamos los valores de la configuración
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = await get_user(db, username) # Se consulta la BD real
    if user is None:
        raise credentials_exception
    return user
</file>

<file path="erp-backend/app/modules/raffles/app/db/base.py">
# app/db/base.py
from sqlalchemy.orm import declarative_base

# La única responsabilidad de este archivo es crear y exportar la Base.
Base = declarative_base()
</file>

<file path="erp-backend/app/modules/raffles/app/db/database.py">
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
# Se elimina la importación de declarative_base
from app.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)
async_session_local = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# Se elimina la línea 'Base = declarative_base()' de este archivo.

async def get_db():
    db = async_session_local()
    try:
        yield db
        await db.commit()
    except Exception:
        await db.rollback()
        raise
    finally:
        await db.close()
</file>

<file path="erp-backend/app/modules/raffles/app/db/models.py">
from sqlalchemy import (
    Column,
    Integer,
    String,
    DateTime,
    ForeignKey,
    Float,
    Enum,
    Text,
    Boolean,
    JSON
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum
from app.db.base import Base
from sqlalchemy.orm import Mapped, mapped_column
# Se importan los nuevos tipos de columna necesarios
from sqlalchemy import (
    Column, Integer, String, DateTime, ForeignKey, Date, Enum
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

# Se importa el Enum que definimos en los esquemas para mantener la consistencia
from app.schemas.ticket import PaymentType
from app.db.base import Base
from sqlalchemy.dialects.postgresql import JSONB


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)

    raffles = relationship("Raffle", back_populates="owner")
    tickets = relationship("Ticket", back_populates="user")


class Raffle(Base):
    __tablename__ = "raffles"
    id: Mapped[str] = mapped_column(String, primary_key=True, index=True)
    short_id = Column(String, unique=True, index=True)
    name = Column(String, index=True)
    description = Column(Text, nullable=True)
    start_date = Column(DateTime(timezone=True), server_default=func.now())
    end_date = Column(DateTime(timezone=True), nullable=False)
    status = Column(String, default="open")
    price = Column(Integer)
    prize_cost = Column(Float, nullable=True, default=0.0)
    numbers_per_ticket = Column(Integer, default=1, nullable=False) # numbers per ticket
    dijits_per_number = Column(Integer)
    image_url = Column(String, nullable=True)
    excluded_numbers = Column(JSON, default=[], nullable=False) # Añadido campo para almacenar los números que no se venderán.O
    owner_id = Column(Integer, ForeignKey("users.id"))

    owner = relationship("User", back_populates="raffles")
    tickets = relationship("Ticket", back_populates="raffle")
    numbers = relationship("Number", back_populates="raffle")


class Ticket(Base):
    __tablename__ = "tickets"

    id = Column(String, primary_key=True, index=True)
    raffle_id = Column(String, ForeignKey("raffles.id"))
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    status = Column(String, default="pending")
    name = Column(String(100)) # Longitud recomendada
    phone = Column(String(20)) # Longitud recomendada
    
    # ---  CAMPOS DE PAGO AÑADIDOS ---
    payment_type = Column(Enum(PaymentType, native_enum=False), nullable=True)
    payment_date = Column(Date, nullable=True)
    payment_proof_url = Column(String(255), nullable=True) # Longitud para URL

    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    raffle = relationship("Raffle", back_populates="tickets")
    user = relationship("User", back_populates="tickets")
    numbers_snapshot = Column(JSONB) # Añadido para almacenar los números comprados en el ticket
    numbers = relationship("Number", back_populates="ticket", cascade="all, delete-orphan")


class Number(Base):
    __tablename__ = "numbers"

    id = Column(Integer, primary_key=True, index=True)
    raffle_id = Column(String, ForeignKey("raffles.id"), nullable=False)
    ticket_id = Column(String, ForeignKey("tickets.id"), nullable=True)
    number = Column(String, nullable=False)
    status = Column(String, default="available", nullable=False)
    expire_at = Column(DateTime(timezone=True), nullable=True)

    ticket = relationship("Ticket", back_populates="numbers")
    raffle = relationship("Raffle")
</file>

<file path="erp-backend/app/modules/raffles/app/db/repositories/raffle.py">
# app/db/repositories/raffle.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, text
from app.modules.raffles.app.db.models import Raffle, Number
from sqlalchemy import select, func, text, String, and_
from app.modules.raffles.app.db.models import Raffle, Number


async def get_raffle_by_id(db: AsyncSession, raffle_id: str):
    result = await db.execute(select(Raffle).where(Raffle.id == raffle_id))
    return result.scalars().first()


async def insert_raffle(db: AsyncSession, raffle: Raffle):
    db.add(raffle)
    await db.commit()
    await db.refresh(raffle)
    return raffle

async def get_all_raffles(db: AsyncSession):
    result = await db.execute(select(Raffle))
    return result.scalars().all()

# --- FUNCIÓN PARA VERIFICAR DISPONIBILIDAD DE NÚMERO ---
# Esta función verifica si un número está disponible para una rifa específica.
# Se consulta directamente la base de datos para evitar conflictos de concurrencia.
# Devuelve True si el número está disponible, False en caso contrario.
async def is_number_available(db: AsyncSession, raffle_id: str, number_str: str) -> bool:
    """
    Verifica la disponibilidad de un número. Un número está disponible si:
    1. No está en la lista de números excluidos de la rifa.
    2. No existe en la tabla Number para esa rifa.
    3. Existe en la tabla Number pero su estado es 'available'.
    """
    # 1. Obtener la rifa para revisar los números excluidos (esto está bien)
    raffle_result = await db.execute(select(Raffle.excluded_numbers).where(Raffle.id == raffle_id))
    excluded_numbers = raffle_result.scalar_one_or_none()

    if excluded_numbers and number_str in excluded_numbers:
        return False # Correcto: No disponible si está excluido

    # 2. Consultar el registro completo del número, no solo su ID
    number_result = await db.execute(
        select(Number).where(Number.raffle_id == raffle_id, Number.number == number_str)
    )
    existing_number = number_result.scalars().first()

    # 3. Nueva Lógica de Decisión
    if existing_number is None:
        # Si el número nunca ha sido tocado (no tiene registro), está disponible.
        return True
    
    # Si el número existe, su disponibilidad depende de su estado.
    return existing_number.status == 'available'

# --- FUNCIÓN PARA OBTENER NÚMEROS ALEATORIOS DISPONIBLES ---
# Esta función obtiene una cantidad específica de números aleatorios disponibles para una rifa.
# Utiliza una consulta SQL optimizada para evitar conflictos de concurrencia.
# Devuelve una lista de números disponibles.

# --- FUNCIÓN REESCRITA: Ahora usa el constructor de consultas de SQLAlchemy ---
async def query_random_available_numbers(
    db: AsyncSession,
    raffle_id: str,
    count: int
) -> list[str]:
    """
    Obtiene 'count' números aleatorios y disponibles para una rifa,
    utilizando el constructor de consultas de SQLAlchemy para mayor seguridad y compatibilidad.
    """
    raffle = await db.get(Raffle, raffle_id)
    if not raffle:
        raise ValueError("Rifa no encontrada.")

    digits = raffle.dijits_per_number
    max_num = (10 ** digits) - 1

    # 1. Se crea una subconsulta que genera todos los números posibles en memoria.
    #    Esto es el equivalente a la cláusula `generate_series` en SQL.
    series = select(
        func.lpad(func.generate_series(0, max_num).cast(String), digits, '0').label('number')
    ).subquery('number_series')

    # 2. Se construye la consulta principal.
    query = (
        select(series.c.number)
        # Se cruza el universo de números con los ya vendidos/reservados.
        .outerjoin(Number, and_(Number.raffle_id == raffle_id, Number.number == series.c.number))
        # Se filtra para quedarse solo con los que NO están en la tabla 'numbers'.
        .where(Number.id == None)
    )

    # 3. Si hay números excluidos, se añade el filtro de forma segura.
    #    SQLAlchemy se encarga de formatear la cláusula NOT IN correctamente.
    if raffle.excluded_numbers:
        query = query.where(series.c.number.not_in(raffle.excluded_numbers))

    # 4. Se aplican el orden aleatorio y el límite al final.
    final_query = query.order_by(func.random()).limit(count)

    result = await db.execute(final_query)
    available_numbers = result.scalars().all()

    if len(available_numbers) < count:
        raise ValueError("No se pudieron generar suficientes números aleatorios disponibles.")
        
    return list(available_numbers)
</file>

<file path="erp-backend/app/modules/raffles/app/db/repositories/ticket.py">
# app/db/repositories/ticket.py

import uuid
import logging # <-- Se importa el módulo de logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload, joinedload
from datetime import datetime, date
from sqlalchemy import update

from app.db.models import Ticket, Number, Raffle, User
from app.modules.raffles.app.schemas.ticket import TicketCreateRequest

# --- Configuración básica de logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - REPO - %(message)s')


# --- FUNCIONES DE LECTURA (READ) ---

async def get_raffle_by_id(db: AsyncSession, raffle_id: str) -> Raffle | None:
    logging.info(f"Buscando rifa con ID: {raffle_id}")
    result = await db.execute(select(Raffle).where(Raffle.id == raffle_id))
    raffle = result.scalars().first()
    if raffle:
        logging.info(f"Rifa '{raffle.name}' encontrada.")
    else:
        logging.warning(f"Rifa con ID {raffle_id} no fue encontrada.")
    return raffle


async def find_and_lock_numbers(db: AsyncSession, raffle_id: str, numbers: list[str]) -> list[Number]:
    if not numbers:
        return []
    logging.info(f"Buscando y bloqueando {len(numbers)} números para la rifa ID: {raffle_id}")
    query = (
        select(Number)
        .where(Number.raffle_id == raffle_id, Number.number.in_(numbers))
        .with_for_update()
    )
    result = await db.execute(query)
    found_numbers = list(result.scalars().all())
    logging.info(f"Se encontraron {len(found_numbers)} registros de números existentes para bloquear.")
    return found_numbers


async def get_ticket_with_numbers_and_raffle(db: AsyncSession, ticket_id: str):
    logging.info(f"Buscando tiquete detallado con ID: {ticket_id}")
    result = await db.execute(
        select(Ticket).options(
            selectinload(Ticket.numbers),
            joinedload(Ticket.raffle),
            joinedload(Ticket.user)
        ).where(Ticket.id == ticket_id)
    )
    return result.scalars().unique().first()



async def get_all_tickets_with_numbers_and_raffle(db: AsyncSession):
    logging.info("Buscando todos los tiquetes con sus relaciones...")
    result = await db.execute(
        select(Ticket).options(
            selectinload(Ticket.numbers),
            joinedload(Ticket.raffle),
            joinedload(Ticket.user)
        )
    )
    tickets = result.scalars().unique().all()
    logging.info(f"Se encontraron {len(tickets)} tiquetes en total.")
    return tickets


# --- FUNCIÓN DE ESCRITURA UNIFICADA ---
async def save_new_ticket(
    db: AsyncSession,
    ticket_data: Ticket,
    existing_numbers: list[Number],
    new_number_strings: set[str],
    expiration_time: datetime | None = None
) -> Ticket:
    """
    Guarda un nuevo tiquete y actualiza/crea sus números.
    """
    logging.info(f"Iniciando guardado de tiquete ID: {ticket_data.id} con estado '{ticket_data.status}'.")
    db.add(ticket_data)
    
    target_status = "reserved" if ticket_data.status == "pending" else "assigned"
    
    # Actualizar números existentes
    if existing_numbers:
        logging.info(f"Actualizando {len(existing_numbers)} números existentes al estado '{target_status}'.")
        for num_obj in existing_numbers:
            num_obj.status = target_status
            num_obj.ticket_id = ticket_data.id
            num_obj.expire_at = expiration_time if ticket_data.status == "pending" else None

    # Crear números nuevos
    if new_number_strings:
        logging.info(f"Creando {len(new_number_strings)} nuevos números con estado '{target_status}'.")
        new_numbers_to_create = [
            Number(
                number=num_str,
                raffle_id=ticket_data.raffle_id,
                ticket_id=ticket_data.id,
                status=target_status,
                expire_at=expiration_time if ticket_data.status == "pending" else None
            )
            for num_str in new_number_strings
        ]
        db.add_all(new_numbers_to_create)

    logging.info(f"Tiquete y números listos para ser confirmados en la transacción.")
    return ticket_data


# --- FUNCIÓN DE CANCELACIÓN ---
async def cancel_ticket_and_release_numbers(db: AsyncSession, ticket: Ticket):
    """
    Actualiza el estado de un tiquete a 'cancelled' y libera sus números asociados.
    """
    logging.info(f"Cancelando tiquete ID: {ticket.id}.")
    ticket.status = "cancelled"
    if ticket.numbers:
        number_ids = [n.id for n in ticket.numbers]
        logging.info(f"Liberando {len(number_ids)} números asociados al tiquete.")
        await db.execute(
            update(Number)
            .where(Number.id.in_(number_ids))
            .values(status="available", ticket_id=None, expire_at=None)
        )

# --- FUNCIÓN DE CONFIRMACIÓN DE PAGO ---
async def confirm_ticket_payment(db: AsyncSession, ticket: Ticket):
    """
    Actualiza el estado de un tiquete a 'paid' y sus números a 'assigned'.
    """
    logging.info(f"Confirmando pago para tiquete ID: {ticket.id}.")
    ticket.status = "paid"
    ticket.payment_date = date.today() # Se establece la fecha de pago al día de hoy
    
    if ticket.numbers:
        number_ids = [n.id for n in ticket.numbers]
        logging.info(f"Actualizando {len(number_ids)} números a 'assigned'.")
        await db.execute(
            update(Number)
            .where(Number.id.in_(number_ids))
            .values(status="assigned", expire_at=None) # Se quita la expiración
        )
</file>

<file path="erp-backend/app/modules/raffles/app/models/__init__.py">
from .user import User, UserInDB

__all__ = ["User", "UserInDB"]
</file>

<file path="erp-backend/app/modules/raffles/app/models/user.py">
from pydantic import BaseModel


class User(BaseModel):
    username: str
    password: str


class UserInDB(BaseModel):
    username: str
    hashed_password: str
</file>

<file path="erp-backend/app/modules/raffles/app/schemas/raffle.py">
# app/schemas/raffle.py
from pydantic import BaseModel, ConfigDict
from datetime import datetime
from typing import List, Optional

# --- Esquema para los tiquetes vendidos (información pública) ---
class SoldTicketInfo(BaseModel):
    id: str  # ID del tiquete para el enlace
    name: str
    numbers: List[str]
    status: str  # Estado real del tiquete
    created_at: datetime  # Fecha de compra
    responsible: Optional[str] = "N/A" # Vendedor responsable

    model_config = ConfigDict(from_attributes=True)

# --- Esquema para las estadísticas ---
class RaffleStatistics(BaseModel):
    tickets_sold: int
    total_tickets: int
    participants: int

# --- Esquema de respuesta de la Rifa (Base para las respuestas) ---
class RaffleResponse(BaseModel):
    id: str
    short_id: str
    name: str
    status: str
    description: Optional[str]
    end_date: datetime
    price: Optional[int]
    prize_cost: Optional[float] = None
    dijits_per_number: Optional[int] = None
    # --- CAMBIOS sutiles para alinear con el modelo ---
    numbers_per_ticket: int
    excluded_numbers: List[str]
    image_url: Optional[str]
    statistics: RaffleStatistics
    model_config = ConfigDict(from_attributes=True)

# --- Esquema para la lista de rifas ---
class RaffleListResponse(BaseModel):
    raffles: List[RaffleResponse]

# --- Esquema para crear una rifa ---
class RaffleCreateRequest(BaseModel):
    name: str
    dijits_per_number: int
    price: int
    end_date: datetime
    status: str
    description: Optional[str] = ""
    prize_cost: Optional[float] = None
    image_url: Optional[str] = ""
    # --- AJUSTE: Se añade un valor por defecto ---
    numbers_per_ticket: int = 1
    excluded_numbers: List[str] = []

# --- Esquema para actualizar una rifa ---
class RaffleUpdateRequest(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[int] = None
    prize_cost: Optional[float] = None
    end_date: Optional[datetime] = None
    status: Optional[str] = None
    image_url: Optional[str] = None
    # --- CAMPOS AÑADIDOS ---
    # Se añaden los campos estructurales como opcionales para permitir su actualización.
    # La lógica de negocio en el servicio decidirá si se pueden modificar o no.
    dijits_per_number: Optional[int] = None
    numbers_per_ticket: Optional[int] = None
    excluded_numbers: Optional[List[str]] = None


# --- AJUSTE CRÍTICO: RaffleDetailResponse ahora HEREDA de RaffleResponse ---
class RaffleDetailResponse(RaffleResponse):
    # Ya no es necesario repetir todos los campos. Se heredan automáticamente.
    # Solo añadimos el campo extra que necesita esta vista detallada.
    sold_tickets: List[SoldTicketInfo]
    model_config = ConfigDict(from_attributes=True)
</file>

<file path="erp-backend/app/modules/raffles/app/schemas/ticket.py">
# app/schemas/ticket.py

from pydantic import BaseModel, ConfigDict
from datetime import datetime, date
from typing import List, Optional
import enum

class PaymentType(str, enum.Enum):
    efectivo = "efectivo"
    transferencia = "transferencia"

# La clase ParticipantRequest ha sido eliminada.

# La clase FinalizeTicketRequest ha sido eliminada.

class ReservedNumber(BaseModel):
    id: int
    number: str
    model_config = ConfigDict(from_attributes=True)

# La clase ReservationResponse ha sido eliminada.

# La clase FinalizedTicketResponse ha sido eliminada.

class TicketCreateRequest(BaseModel):
    raffle_id: str
    numbers: List[str]
    name: str
    phone: str
    payment_type: PaymentType
    status: Optional[str] = "pending"  # Por defecto, el estado es 'pending'
    payment_date: Optional[date] = None
    payment_proof_url: Optional[str] = None

class TicketInfo(BaseModel):
    id: str
    name: str
    phone: str
    raffle_id: str
    status: str
    responsible: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime]
    payment_type: Optional[PaymentType] = None
    payment_date: Optional[date] = None
    payment_proof_url: Optional[str] = None
    numbers: List[str]
    numbers_snapshot: Optional[List[str]] = None # <-- AÑADIR ESTA LÍNEA
    number_ids: List[int]
    raffle_name: str
    raffle_status: str
    raffle_short_id: str
    raffle_end_date: datetime
    raffle_price: float
    model_config = ConfigDict(from_attributes=True)

class TicketListResponse(BaseModel):
    tickets: List[TicketInfo]
</file>

<file path="erp-backend/app/modules/raffles/app/schemas/user.py">
# raffle-backend/app/schemas/user.py

from pydantic import BaseModel

# ✅ ESQUEMA AÑADIDO: Define la estructura para crear un nuevo usuario.
class UserCreate(BaseModel):
    username: str
    password: str

# Puedes añadir aquí otros esquemas de User si los necesitas, por ejemplo, para las respuestas del API.
class User(BaseModel):
    id: int
    username: str

    class Config:
        from_attributes = True
</file>

<file path="erp-backend/app/modules/raffles/app/services/auth.py">
# app/services/auth.py


from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

# Se importan los modelos y esquemas necesarios
from app.db.models import User
from app.schemas.user import UserCreate
from app.modules.raffles.app.core.security import get_password_hash # Asumiendo que esta función está en security.py

# --- Función Auxiliar para buscar usuarios ---
async def get_user_by_username(db: AsyncSession, username: str) -> User | None:
    """
    Busca un usuario por su nombre de usuario.
    """
    result = await db.execute(select(User).where(User.username == username))
    return result.scalars().first()


# --- Servicio para Crear un Nuevo Usuario ---
async def create_user_service(db: AsyncSession, user_data: UserCreate) -> User:
    """
    Crea un nuevo usuario en la base de datos, verificando que no exista previamente.
    """
    # 1. Verificar si el usuario ya existe
    existing_user = await get_user_by_username(db, user_data.username)
    if existing_user:
        # Es una buena práctica lanzar un error específico que el endpoint pueda capturar.
        raise ValueError("El nombre de usuario ya está en uso.")

    # 2. Hashear la contraseña antes de guardarla
    hashed_password = get_password_hash(user_data.password)

    # 3. Crear la instancia del modelo User
    # NOTA: No se asigna el 'id'. La base de datos lo genera automáticamente
    # porque es un Integer autoincremental. Esta es la corrección al plan original.
    new_user = User(
        username=user_data.username,
        hashed_password=hashed_password
    )

    # 4. Añadir a la sesión, confirmar y refrescar para obtener el ID asignado
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)

    return new_user
</file>

<file path="erp-backend/app/modules/raffles/app/services/generate_image.py">
from fastapi import HTTPException
from PIL import Image, ImageDraw, ImageFont
from pathlib import Path
from datetime import datetime
import locale

# Se configura el locale a español para que los nombres de los meses salgan correctamente.
# Esto puede requerir que el locale 'es_ES.UTF-8' esté disponible en tu sistema operativo.
try:
    locale.setlocale(locale.LC_TIME, 'es_ES.UTF-8')
except locale.Error:
    try:
        locale.setlocale(locale.LC_TIME, 'Spanish_Spain.1252')
    except locale.Error:
        print("Advertencia: No se pudo establecer el locale a español. Los meses podrían aparecer en inglés.")


# Se construyen las rutas de forma robusta
try:
    BASE_DIR = Path(__file__).resolve().parent.parent
    TEMPLATE_IMAGE_PATH = BASE_DIR / "assets/hhhh.jpg"
    FONT_PATH = BASE_DIR / "assets/ARIAL.TTF"
except Exception as e:
    raise ImportError(f"No se pudieron construir las rutas base de los assets: {e}")

def draw_text_centered(draw, y, text, font, fill_color):
    """Función de ayuda para dibujar texto centrado horizontalmente."""
    img_width, _ = draw.im.size
    try:
        text_bbox = draw.textbbox((0, y), text, font=font)
        text_width = text_bbox[2] - text_bbox[0]
        x = (img_width - text_width) / 2
        draw.text((x, y), text, font=font, fill=fill_color)
    except Exception:
        text_width, _ = draw.textsize(text, font=font)
        x = (img_width - text_width) / 2
        draw.text((x, y), text, font=font, fill=fill_color)

def generate_raffle_image(ticket_data: dict):
    """
    Genera una imagen de comprobante de compra con todos los datos pertinentes,
    con el contenido centrado vertical y horizontalmente.
    """
    try:
        template = Image.open(TEMPLATE_IMAGE_PATH)
        img = template.copy().convert("RGBA")
    except FileNotFoundError:
        raise HTTPException(status_code=500, detail="Error Crítico: No se encontró la plantilla de imagen.")

    img_width, img_height = img.size
    overlay = Image.new("RGBA", img.size, (255, 255, 255, 0))
    draw = ImageDraw.Draw(overlay)

    # --- 1. Definición de Fuentes y Colores ---
    try:
        font_title = ImageFont.truetype(str(FONT_PATH), 60)
        font_subtitle = ImageFont.truetype(str(FONT_PATH), 35)
        font_main = ImageFont.truetype(str(FONT_PATH), 40)
        font_numbers = ImageFont.truetype(str(FONT_PATH), 45)
        font_small = ImageFont.truetype(str(FONT_PATH), 25)
    except IOError:
        # Fallback a fuentes por defecto si no se encuentra el archivo ARIAL.TTF
        font_title, font_subtitle, font_main, font_numbers, font_small = [ImageFont.load_default(s) for s in [60, 35, 40, 45, 25]]

    text_color = (0, 0, 0)

    # --- 2. Extracción y Formateo de TODOS los Datos ---
    raffle_name = ticket_data.get("raffle_name", "N/A")
    ticket_id = ticket_data.get("ticket_id", "N/A")
    buyer_name = ticket_data.get("buyer_name", "N/A")
    numbers_str = ", ".join(sorted(ticket_data.get("numbers", [])))
    
    # Se añade la fecha de compra que faltaba
    purchase_date_str = ticket_data.get("purchase_date", "Fecha no definida")
    
    draw_date_str = ticket_data.get("draw_date", "Fecha no definida")

    total_price = ticket_data.get("total_price", 0)
    price_str = f"${total_price:,.0f} COP" if total_price > 0 else "N/A"

    # --- 3. Lógica para Centrado Vertical ---

    # Se define todo el contenido que se va a dibujar
    content_lines = [
        ("¡Compra Exitosa!", font_title, 20),
        (f"Rifa: {raffle_name}", font_subtitle, 40),
        (f"Comprador: {buyer_name}", font_main, 15),
        (f"Fecha de Compra: {purchase_date_str}", font_main, 15),
        (f"Total Pagado: {price_str}", font_main, 40),
        ("Tus Números:", font_title, 20),
        (numbers_str, font_numbers, 40),
        (f"Fecha del Sorteo: {draw_date_str}", font_subtitle, 50),
        (f"ID de Transacción: {ticket_id}", font_small, 5),
        ("Conserva este comprobante. ¡Mucha suerte!", font_small, 0)
    ]

    # Se calcula la altura total del bloque de texto
    total_content_height = sum(font.getbbox(text)[3] - font.getbbox(text)[1] + spacing for text, font, spacing in content_lines)

    # Se calcula la posición 'y' inicial para centrar el bloque
    y = (img_height - total_content_height) / 2

    # --- 4. Dibujo del Fondo Blanco y los Textos ---

    # El fondo blanco se dibuja dinámicamente alrededor del contenido
    padding = 60
    box_y1 = y - padding
    box_y2 = y + total_content_height + padding
    box_xy = [60, box_y1, img_width - 60, box_y2]
    draw.rectangle(box_xy, fill=(255, 255, 255, 210)) # Fondo blanco con ligera transparencia

    # Se dibuja cada línea de texto, ahora perfectamente centrada
    for text, font, spacing in content_lines:
        line_height = font.getbbox(text)[3] - font.getbbox(text)[1]
        draw_text_centered(draw, y, text, font, text_color)
        y += line_height + spacing # Se incrementa 'y' para la siguiente línea

    # --- 5. Composición Final de la Imagen ---
    img_with_overlay = Image.alpha_composite(img, overlay)
    return img_with_overlay.convert("RGB")
</file>

<file path="erp-backend/app/modules/raffles/app/services/raffle_service.py">
# app/services/raffle_service.py
import uuid
import random
import string
from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text, select, func, and_, cast, Integer
from sqlalchemy.orm import selectinload
from sqlalchemy.orm import Mapped, mapped_column

from app.schemas.raffle import RaffleCreateRequest, RaffleResponse, RaffleStatistics, SoldTicketInfo, RaffleUpdateRequest, RaffleDetailResponse
from app.db.models import Raffle, Ticket, Number, User
from app.modules.raffles.app.db.repositories.raffle import is_number_available, query_random_available_numbers



# --- FUNCIÓN AUXILIAR PARA GENERAR ID CORTO ---
def generate_short_id(length=5):
    """Genera un ID corto alfanumérico en mayúsculas."""
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))

# --- FUNCIÓN PARA CREAR UNA NUEVA RIFA ---
async def create_raffle_service(data: RaffleCreateRequest, db: AsyncSession, user: User) -> str:
    """
    Crea una nueva rifa, valida la configuración de paquetes y números excluidos,
    y guarda dichos números como no disponibles en la base de datos.
    """
    print(f"[BACKEND - Service] create_raffle_service llamado con los datos validados.")
    # 1. Validación de la lógica de negocio para paquetes (sin cambios)
    if data.numbers_per_ticket <= 0:
        raise ValueError("La cantidad de números por tiquete debe ser mayor a cero.")

    universo = 10 ** data.dijits_per_number
    numeros_a_excluir_calculados = universo % data.numbers_per_ticket

    # Se valida que la cantidad de números excluidos en la lista coincida con el cálculo
    if len(data.excluded_numbers) != numeros_a_excluir_calculados:
        raise ValueError(
            f"Error de integridad: La cantidad de números excluidos ({len(data.excluded_numbers)}) "
            f"no coincide con la cantidad requerida por el cálculo ({numeros_a_excluir_calculados})."
        )

    # 2. Creación del objeto Rifa (sin cambios)
    raffle_id = str(uuid.uuid4())
    while True:
        short_id = generate_short_id()
        result = await db.execute(select(Raffle).where(Raffle.short_id == short_id))
        if result.scalars().first() is None:
            break

    new_raffle = Raffle(
        id=raffle_id,
        short_id=short_id,
        name=data.name,
        dijits_per_number=data.dijits_per_number,
        numbers_per_ticket=data.numbers_per_ticket,
        excluded_numbers=data.excluded_numbers,
        end_date=data.end_date,
        price=data.price,
        prize_cost=data.prize_cost,
        status=data.status,
        description=data.description,
        owner_id=user.id,
        image_url=data.image_url,
    )
    db.add(new_raffle)

    # --- PASO ADICIONAL: Guardar los números excluidos en la tabla 'Number' ---
    if data.excluded_numbers:
        # Se crea una lista de objetos 'Number' para cada número excluido
        excluded_number_objects = [
            Number(
                raffle_id=raffle_id,
                number=num_str,
                status='excluded' # Estado que los marca como no disponibles para la venta
            )
            for num_str in data.excluded_numbers
        ]
        # Se añaden todos los nuevos objetos a la sesión de la base de datos
        db.add_all(excluded_number_objects)

    # 4. Se confirman todos los cambios en una sola transacción
    await db.commit()
    await db.refresh(new_raffle)
    return new_raffle

# --- FUNCIÓN PARA ACTUALIZAR UNA RIFA ---
# Esta función actualiza los detalles de una rifa existente, asegurándose de que no se cambien los dígitos de una rifa que ya tiene tiquetes vendidos.
async def update_raffle_service(raffle_id: str, data: RaffleUpdateRequest, db: AsyncSession) -> RaffleDetailResponse:
    """
    Actualiza una rifa existente de forma segura, cargando todas las relaciones
    necesarias explícitamente y devolviendo la respuesta detallada completa.
    """
    # 1. Obtener la rifa cargando sus relaciones de forma explícita (Eager Loading)
    #    Esto previene el error 'greenlet_spawn'.
    query = (
        select(Raffle)
        .options(
            selectinload(Raffle.tickets).selectinload(Ticket.numbers), # Carga tiquetes y sus números
            selectinload(Raffle.owner)                                # Carga el dueño
        )
        .where(Raffle.id == raffle_id)
    )
    result = await db.execute(query)
    raffle_in_db = result.scalars().first()
    
    if not raffle_in_db:
        raise ValueError("La rifa no fue encontrada.")

    # --- LÓGICA DE VALIDACIÓN MEJORADA ---
    # Se verifica si existe algún tiquete que NO esté cancelado.
    has_active_tickets = any(ticket.status not in ['cancelled'] for ticket in raffle_in_db.tickets)
    # Obtiene un diccionario solo con los campos que el frontend envió
    update_data = data.model_dump(exclude_unset=True)

    if has_active_tickets:
        allowed_keys = {'end_date', 'status', 'description', 'image_url', 'name'} # Campos permitidos
        
        # Se comprueba si se está intentando modificar un campo no permitido
        if not set(update_data.keys()).issubset(allowed_keys):
            raise ValueError("Esta rifa ya tiene tiquetes activos (vendidos o pendientes). No se puede modificar su estructura (dígitos, precio, etc.).")
    
    # Si no hay tiquetes activos, se permite la actualización de cualquier campo.
    for key, value in update_data.items():
        if value is not None:
            setattr(raffle_in_db, key, value)
    
    db.add(raffle_in_db)
    await db.commit()
    
    # Se refrescan las relaciones que podrían haber cambiado o que se necesitan para la respuesta
    await db.refresh(raffle_in_db, attribute_names=['tickets', 'owner'])
    
    return _build_raffle_detail_response(raffle_in_db)

# --- FUNCIÓN AUXILIAR CORREGIDA ---
# Esta función construye la respuesta de una rifa, incluyendo estadísticas y participantes.
# Se asegura de que los cálculos de estadísticas sean correctos y se manejen adecuadamente los números excluidos.   
def _build_raffle_response(raffle: Raffle, tickets_sold: int, participants: int) -> RaffleResponse:
    # --- LÓGICA DE ESTADÍSTICAS CORREGIDA ---
    # 1. Se calcula el universo total de números.
    universo = 10 ** raffle.dijits_per_number if raffle.dijits_per_number else 0
    
    # 2. Se calcula el total de números que se pueden vender.
    numeros_vendibles = universo - len(raffle.excluded_numbers)
    
    # 3. Se calcula cuántos tiquetes (paquetes) se pueden vender en total.
    # Se usa división entera (//) por si acaso, aunque la exclusión ya debería garantizarlo.
    total_tickets_posibles = numeros_vendibles // raffle.numbers_per_ticket

    statistics = RaffleStatistics(
        tickets_sold=tickets_sold,
        total_tickets=total_tickets_posibles, # <-- Se usa el cálculo correcto.
        participants=participants
    )

    # --- RESPUESTA CORREGIDA ---
    return RaffleResponse(
        id=raffle.id,
        short_id=raffle.short_id,
        name=raffle.name,
        status=raffle.status,
        description=raffle.description,
        end_date=raffle.end_date,
        price=raffle.price,
        prize_cost=raffle.prize_cost,
        dijits_per_number=raffle.dijits_per_number,
        image_url=raffle.image_url,
        
        # <-- Se eliminan los campos obsoletos 'total_numbers' y 'excluded_number'.
        
        # <-- Se añaden los nuevos campos requeridos por el schema.
        numbers_per_ticket=raffle.numbers_per_ticket,
        excluded_numbers=raffle.excluded_numbers,
        
        statistics=statistics,
    )

# --- FUNCIÓN AUXILIAR PARA DETALLES DE RIFA ---
# Esta función construye la respuesta detallada de una rifa, incluyendo estadísticas y tiquetes vendidos.
def _build_raffle_detail_response(raffle: Raffle) -> RaffleDetailResponse:
    """
    Construye la respuesta detallada de una rifa, incluyendo estadísticas precisas
    y una lista completa de los tiquetes activos (pagados y pendientes) con toda
    la información necesaria para el frontend.
    """
    # --- LÓGICA DE ESTADÍSTICAS (SIN CAMBIOS) ---
    universo = 10 ** raffle.dijits_per_number if raffle.dijits_per_number else 0
    numeros_vendibles = universo - len(raffle.excluded_numbers)
    total_tickets_posibles = numeros_vendibles // raffle.numbers_per_ticket if raffle.numbers_per_ticket > 0 else 0

    # --- LÓGICA DE FILTRADO Y CONTEO (AJUSTADA) ---
    
    # 1. Filtramos para obtener tiquetes que no estén cancelados (es decir, pagados y pendientes)
    active_tickets = [t for t in raffle.tickets if t.status in ['paid', 'pending']]
    
    # 2. El conteo de "tiquetes vendidos" ahora incluye tanto pagados como pendientes para las estadísticas de progreso.
    tickets_sold_count = len(active_tickets)
    
    # 3. El conteo de participantes únicos se basa en los tiquetes activos.
    participants_count = len(set(t.name for t in active_tickets))

    statistics = RaffleStatistics(
        tickets_sold=tickets_sold_count,
        total_tickets=total_tickets_posibles,
        participants=participants_count
    )
    
    # --- CONSTRUCCIÓN DE LA LISTA DE TIQUETES (CORREGIDA Y ENRIQUECIDA) ---
    # Aquí está el cambio principal: ahora poblamos el objeto SoldTicketInfo
    # con todos los datos que el frontend necesita.
    sold_tickets_info = []
    for t in active_tickets:
        sold_tickets_info.append(
            SoldTicketInfo(
                id=t.id,
                name=t.name,
                numbers=[n.number for n in t.numbers],
                status=t.status,
                created_at=t.created_at,
                responsible=t.user.username if t.user else "Sistema" # Manejo seguro por si no hay usuario
            )
        )

    # --- RESPUESTA FINAL (SIN CAMBIOS ESTRUCTURALES) ---
    return RaffleDetailResponse(
        id=raffle.id,
        short_id=raffle.short_id,
        name=raffle.name,
        status=raffle.status,
        description=raffle.description,
        end_date=raffle.end_date,
        price=raffle.price,
        prize_cost=raffle.prize_cost,
        dijits_per_number=raffle.dijits_per_number,
        image_url=raffle.image_url,
        numbers_per_ticket=raffle.numbers_per_ticket,
        excluded_numbers=raffle.excluded_numbers,
        statistics=statistics,
        sold_tickets=sold_tickets_info # <-- Ahora esta lista contiene toda la información
    )

# --- FUNCIÓN PARA LISTAR LAS RIFAS ---
async def list_raffles_service(db: AsyncSession) -> list[RaffleResponse]:
    subquery_tickets_sold = (
        select(Ticket.raffle_id, func.count(Number.id).label("tickets_sold_count"))
        .join(Number, Ticket.id == Number.ticket_id)
        .where(Ticket.status == 'paid')
        .group_by(Ticket.raffle_id)
        .subquery()
    )
    subquery_participants = (
        select(Ticket.raffle_id, func.count(func.distinct(Ticket.name)).label("participants_count"))
        .where(Ticket.status == 'paid')
        .group_by(Ticket.raffle_id)
        .subquery()
    )
    query = (
        select(Raffle,
               func.coalesce(subquery_tickets_sold.c.tickets_sold_count, 0).label("tickets_sold"),
               func.coalesce(subquery_participants.c.participants_count, 0).label("participants"))
        .outerjoin(subquery_tickets_sold, Raffle.id == subquery_tickets_sold.c.raffle_id)
        .outerjoin(subquery_participants, Raffle.id == subquery_participants.c.raffle_id)
    )
    result = await db.execute(query)
    
# 1. Primero. creo una lista vacía para almacenar el objeto rifa completo, los tiquetes vendidos y los participantes.
    raffles_responses = []
# 2. Obtiene todos los resultados únicos de la consulta de la base de datos.
#    El resultado es una lista donde cada elemento es una tupla, por ejemplo:
#    (objeto_Raffle, 10, 5)
    database_rows = result.unique().all()

    for row in database_rows:
        raffle_object = row.Raffle
        tickets_sold = row.tickets_sold
        participants = row.participants

        raffle_response = _build_raffle_response(raffle_object, tickets_sold, participants)
        raffles_responses.append(raffle_response)

    return raffles_responses

# --- FUNCIÓN PARA OBTENER DETALLES DE UNA RIFA ---
async def get_raffle_service(raffle_id: str, db: AsyncSession) -> RaffleDetailResponse:
    query = (
        select(Raffle)
        .options(
            selectinload(Raffle.tickets)
            .selectinload(Ticket.user), # <-- AÑADE ESTA LÍNEA
            selectinload(Raffle.tickets)
            .selectinload(Ticket.numbers)
        )
        .where(Raffle.id == raffle_id)
    )
    result = await db.execute(query)
    raffle = result.scalars().unique().first()

    if not raffle:
        raise ValueError("Raffle not found")
    return _build_raffle_detail_response(raffle)

# --- FUNCIÓN PARA VERIFICAR DISPONIBILIDAD DE NÚMERO ---
# Esta función llama a la función is_number_available del repositorio para verificar si un número está disponible para una rifa específica.
# Se usa para evitar conflictos de concurrencia y asegurar que el número no esté reservado o asignado.
async def check_number_availability_service(raffle_id: str, number_str: str, db: AsyncSession) -> bool:
    return await is_number_available(db, raffle_id, number_str)

# --- FUNCIÓN PARA OBTENER NÚMEROS ALEATORIOS DISPONIBLES ---
#Esta funcion llama a la función query_random_available_numbers del repositorio para obtener una cantidad específica de números aleatorios disponibles para una rifa.
# Se usa para evitar conflictos de concurrencia y asegurar que los números no estén reservados o asignados.
async def get_random_available_numbers_service(
    raffle_id: str,
    count: int,
    db: AsyncSession
) -> list[str]:
    """
    Obtiene N números aleatorios y disponibles, delegando la consulta
    a la capa de repositorios y validando el resultado.
    """
    # 1. La lógica de negocio es llamar al repositorio
    available_numbers = await query_random_available_numbers(db, raffle_id, count)
    
    # 2. El servicio se encarga de la validación de negocio
    if len(available_numbers) < count:
        raise ValueError("No se pudieron generar suficientes números aleatorios disponibles.")
        
    return available_numbers
</file>

<file path="erp-backend/app/modules/raffles/app/services/send_whatsapp_message.py">
import aiohttp
import json

# Configuration
ACCESS_TOKEN = "EAAKaX4DAZCwcBO2PoU05EAtOKmj0skRQbpNl9wi53riogjWkE5bNXenKLBtfoLtFsRt4lEwhtA0f7A9Pmkyu2wcZAy92A8dB3pt5nBX4g6NqCkKPY9exiw8Hn2u9kOm9nsw9LRSx1DKZCdnvZCgCUh7Dr0KhvMPc8C0mZBwG0ZBuSx4dV9sdAb7FWaH1hmDQZDZD"
PHONE_NUMBER_ID = "649273224941709" 
API_VERSION = "v22.0"  # Current API version
 
async def send_purchase_notification(recipient, name_param, receipt_param):
    # Purchase notification function
    #   Args:
    #   recipient: Phone number of the recipient
    #   name_param: Name of the client
    #   receipt_param: Parameter for the receipt (TODO: Change to the actual receipt)

    headers = {
        "Content-type": "application/json",
        "Authorization": f"Bearer {ACCESS_TOKEN}",
    }

    components = [
        {
            "type": "body",
            "parameters": [{"type": "text", "parameter_name": "name",  "text": name_param}]
        },
        {
            "type": "button",
            "sub_type": "url",
            "index": 0,
            "parameters": [
                {
                    "type": "text",
                    "text": receipt_param
                }
            ]
        }
    ]

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": recipient,
        "type": "template",
        "template": {
            "name": "demo",
            "language": {"code": "es_CO"},
            "components": components
        }
    }

    url = f"https://graph.facebook.com/{API_VERSION}/{PHONE_NUMBER_ID}/messages"

    async with aiohttp.ClientSession() as session:
        try:
            async with session.post(url, data=json.dumps(payload), headers=headers) as response:
                if response.status == 200:
                    result = await response.json()
                    print("Message sent successfully!")
                    print(f"Message ID: {result['messages'][0]['id']}")
                    return result
                else:
                    error = await response.text()
                    print(f"Error {response.status}: {error}")
                    return None
        except aiohttp.ClientConnectorError as e:
            print(f'Connection Error: {str(e)}')
            return None
</file>

<file path="erp-backend/app/modules/raffles/app/services/ticket_service.py">
# raffle-frontend/src/services/ticket_service.py

import uuid
import logging # <-- Se importa el módulo de logging
from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from zoneinfo import ZoneInfo

from app.db.repositories.ticket import (
    get_raffle_by_id,
    find_and_lock_numbers,
    save_new_ticket,
    get_all_tickets_with_numbers_and_raffle,
    get_ticket_with_numbers_and_raffle,
    cancel_ticket_and_release_numbers,
    confirm_ticket_payment,
)
from app.db.models import Ticket, User
from app.schemas.ticket import TicketCreateRequest, TicketInfo
from app.modules.raffles.app.services.send_whatsapp_message import send_purchase_notification

# --- Configuración básica de logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - SERVICE - %(message)s')


async def create_ticket_service(data: TicketCreateRequest, db: AsyncSession, user: User) -> Ticket:
    """
    Orquesta la creación de un tiquete. La transacción es manejada por la dependencia get_db.
    """
    logging.info(f"Iniciando create_ticket_service para la rifa ID: {data.raffle_id} por el usuario '{user.username}'.")
    
    # --- Se elimina el bloque 'async with db.begin()' ---
    
    raffle = await get_raffle_by_id(db, data.raffle_id)
    if not raffle or raffle.status.lower() not in ['active', 'open']:
        logging.error(f"Validación fallida: La rifa {data.raffle_id} no existe o no está activa.")
        raise ValueError("La rifa no existe o no está activa.")
    logging.info("Validación de rifa exitosa.")

    existing_numbers = await find_and_lock_numbers(db, data.raffle_id, data.numbers)
    for num in existing_numbers:
        if num.status != 'available':
            logging.error(f"Validación fallida: El número {num.number} ya no está disponible.")
            raise ValueError(f"El número {num.number} ya no está disponible.")
    logging.info("Validación de disponibilidad de números exitosa.")

    
    # --- NUEVA LÓGICA ---
    # Confiamos directamente en el estado que nos envía el frontend.
    # Se realiza una validación simple para asegurar que el valor sea uno de los esperados.
    ticket_status = data.status.lower()
    if ticket_status not in ['paid', 'pending']:
        logging.error(f"Estado '{ticket_status}' no válido enviado desde el frontend.")
        raise ValueError("El estado del tiquete proporcionado no es válido.")
    logging.info(f"Lógica de negocio: El estado del tiquete se recibe del frontend como '{ticket_status}'.")

   # --- BLOQUE DE LÓGICA MODIFICADO ---
    expiration_time = None
    if ticket_status == "pending":
        if data.payment_date:
            # Si el tiquete es pendiente y el usuario dio una fecha, la usamos.
            logging.info(f"Tiquete 'pending' con fecha de pago programada: {data.payment_date}.")
            try:
                # Zona horaria de Cali/Colombia
                colombia_tz = ZoneInfo("America/Bogota")
                
                # Definimos la hora como el último momento del día.
                end_of_day_time = datetime.max.time().replace(microsecond=0)
                
                # Combinamos la fecha del usuario con la hora de fin del día.
                naive_datetime = datetime.combine(data.payment_date, end_of_day_time)
                
                # Asignamos la zona horaria correcta, creando un datetime "aware".
                expiration_time = naive_datetime.astimezone(colombia_tz)
                
                logging.info(f"Expiración establecida para (en zona horaria de Colombia): {expiration_time}")

            except Exception as e:
                logging.error(f"Error al procesar la zona horaria 'America/Bogota'. Asegúrese de que 'tzdata' esté disponible. Error: {e}. Usando fallback de 15 minutos.")
                # Fallback en caso de error con la zona horaria
                expiration_time = datetime.now(timezone.utc) + timedelta(minutes=15)
        else:
            # Si es pendiente pero no tiene fecha (no debería pasar con la lógica del front),
            # usamos un tiempo de gracia corto por seguridad.
            logging.warning("Tiquete 'pending' sin fecha de pago especificada. Usando expiración de 15 minutos por defecto.")
            expiration_time = datetime.now(timezone.utc) + timedelta(minutes=15)
    # --- FIN DEL BLOQUE MODIFICADO ---
    

    new_ticket_obj = Ticket(
        id=str(uuid.uuid4()),
        raffle_id=data.raffle_id,
        user_id=user.id,
        name=data.name,
        phone=data.phone,
        status=ticket_status,
        payment_type=data.payment_type,
        payment_date=data.payment_date,
        payment_proof_url=data.payment_proof_url,
        numbers_snapshot=data.numbers # <-- ¡AQUÍ GUARDAS LA FOTOGRAFÍA!
    )

    existing_numbers_map = {n.number for n in existing_numbers}
    new_number_strings = set(data.numbers) - existing_numbers_map
    logging.info(f"Preparando para guardar {len(existing_numbers)} números existentes y {len(new_number_strings)} números nuevos.")

    created_ticket = await save_new_ticket(
        db=db,
        ticket_data=new_ticket_obj,
        existing_numbers=existing_numbers,
        new_number_strings=new_number_strings,
        expiration_time=expiration_time
    )
    
    await db.flush()
        
    await db.refresh(created_ticket, attribute_names=['numbers', 'user'])
    
    # La notificación se envía después de que la transacción (manejada por get_db) sea exitosa.
    if created_ticket.status == 'paid':
        logging.info(f"Tiquete pagado. Enviando notificación de WhatsApp al número {created_ticket.phone}.")
        await send_purchase_notification(
            created_ticket.phone, 
            created_ticket.name, 
            created_ticket.id
        )
    
    logging.info(f"Servicio finalizado. Devolviendo tiquete ID: {created_ticket.id}")
    return created_ticket


async def list_tickets_service(db: AsyncSession) -> list[TicketInfo]:
    logging.info("Iniciando list_tickets_service...")
    # La limpieza de tiquetes expirados se puede añadir aquí si se retoma la lógica de 'pending'
    # await cleanup_expired_tickets(db)
    
    tickets = await get_all_tickets_with_numbers_and_raffle(db)
    logging.info(f"Se obtuvieron {len(tickets)} tiquetes del repositorio. Mapeando a TicketInfo...")
    
    ticket_responses = []
    for ticket in tickets:
        # Un tiquete cancelado no tendrá números, pero sigue siendo válido para listar.
        # Solo omitimos si falta la rifa, lo que indica un error de datos.
        if not ticket.raffle:
            logging.warning(f"Omitiendo tiquete ID {ticket.id} por no tener una rifa asociada.")
            continue
            
        raffle = ticket.raffle
        ticket_info = TicketInfo(
            id=ticket.id,
            name=ticket.name,
            phone=ticket.phone,
            raffle_id=ticket.raffle_id,
            status=ticket.status,
            responsible=ticket.user.username if ticket.user else None,
            created_at=ticket.created_at,
            updated_at=ticket.updated_at,
            payment_type=ticket.payment_type,
            payment_date=ticket.payment_date,
            payment_proof_url=ticket.payment_proof_url,
            numbers=[n.number for n in ticket.numbers],
            numbers_snapshot=ticket.numbers_snapshot,  # <-- AÑADIR ESTA LÍNE
            number_ids=[n.id for n in ticket.numbers],
            raffle_name=raffle.name,
            raffle_status=raffle.status,
            raffle_short_id=raffle.short_id,
            raffle_end_date=raffle.end_date,
            raffle_price=raffle.price
        )
        ticket_responses.append(ticket_info)
    
    logging.info(f"Mapeo completado. Devolviendo {len(ticket_responses)} tiquetes.")
    return ticket_responses


async def get_ticket_by_id_service(ticket_id: str, db: AsyncSession) -> TicketInfo | None:
    logging.info(f"Iniciando get_ticket_by_id_service para el ID: {ticket_id}")
    ticket = await get_ticket_with_numbers_and_raffle(db, ticket_id)
    if not ticket: 
        logging.warning(f"Tiquete con ID {ticket_id} no fue encontrado en el repositorio.")
        return None
        
    logging.info("Tiquete encontrado. Mapeando a TicketInfo...")
    raffle = ticket.raffle
    ticket_info = TicketInfo(
        id=ticket.id,
        name=ticket.name,
        phone=ticket.phone,
        raffle_id=ticket.raffle_id,
        status=ticket.status,
        responsible=ticket.user.username if ticket.user else None,
        created_at=ticket.created_at,
        updated_at=ticket.updated_at,
        payment_type=ticket.payment_type,
        payment_date=ticket.payment_date,
        payment_proof_url=ticket.payment_proof_url,
        numbers=[n.number for n in ticket.numbers],
        number_ids=[n.id for n in ticket.numbers],
        raffle_name=raffle.name,
        raffle_status=raffle.status,
        raffle_short_id=raffle.short_id,
        raffle_end_date=raffle.end_date,
        raffle_price=raffle.price,
    )
    logging.info("Mapeo completado. Devolviendo tiquete.")
    return ticket_info


async def cancel_ticket_service(ticket_id: str, db: AsyncSession):
    """
    Cancela un tiquete orquestando las operaciones a través de la capa de repositorios.
    """
    logging.info(f"Iniciando cancel_ticket_service para el ID: {ticket_id}")
    # La transacción es manejada por la dependencia get_db, se elimina el bloque begin()
    ticket = await get_ticket_with_numbers_and_raffle(db, ticket_id)
    
    if not ticket:
        logging.error(f"Validación fallida: El tiquete con ID {ticket_id} no fue encontrado.")
        raise ValueError(f"El tiquete con ID {ticket_id} no fue encontrado.")
    
    logging.info("Tiquete encontrado. Llamando al repositorio para cancelar y liberar números.")
    await cancel_ticket_and_release_numbers(db, ticket)
    logging.info("Operaciones de cancelación completadas, esperando commit de get_db.")

async def confirm_payment_service(ticket_id: str, db: AsyncSession):
    """
    Confirma el pago de un tiquete pendiente.
    """
    logging.info(f"Iniciando confirm_payment_service para el ID: {ticket_id}")
    # La transacción es manejada por la dependencia get_db, se elimina el bloque begin()
    ticket = await get_ticket_with_numbers_and_raffle(db, ticket_id)
    
    if not ticket:
        logging.error(f"Validación fallida: El tiquete con ID {ticket_id} no fue encontrado.")
        raise ValueError(f"El tiquete con ID {ticket_id} no fue encontrado.")
        
    if ticket.status != 'pending':
        logging.warning(f"El tiquete {ticket_id} no está en estado 'pending' (estado actual: {ticket.status}). No se puede confirmar el pago.")
        raise ValueError(f"Solo se puede confirmar el pago de tiquetes pendientes.")
        
    logging.info("Tiquete encontrado y validado. Llamando al repositorio para confirmar pago.")
    await confirm_ticket_payment(db, ticket)
    logging.info("Operaciones de confirmación de pago completadas, esperando commit de get_db.")
</file>

<file path="erp-backend/app/modules/raffles/app/utils/auth.py">
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)
</file>

<file path="erp-backend/app/modules/raffles/app/utils/cleanup.py">
import os

def cleanup_temp_file(file_path: str):
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
    except Exception as e:
        print(f"Warning: Could not remove temporary file {file_path}: {e}")
</file>

<file path="erp-backend/app/modules/raffles/app/utils/test_data.py">
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
    },
    "admin": {
        "username": "admin",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
    },
}
</file>

<file path="erp-backend/app/modules/raffles/create_first_user.py">
import asyncio
import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import datetime, timedelta, timezone

# --- Importaciones Adicionales ---
from app.db.database import async_session_local
from app.db.models import User, Raffle # <-- Se importa el modelo Raffle
from app.core.security import get_password_hash
from app.services.raffle_service import generate_short_id # <-- Se importa el generador de short_id

# --- Configuración ---
USERS_TO_CREATE = [
    {"username": "admin", "password": "admin123"},
    {"username": "vendedor", "password": "vendedor123"}
]
ADMIN_USERNAME = "admin" # Define quién será el dueño de la rifa de prueba

async def seed_database():
    """
    Crea los usuarios y una rifa de prueba, solo si no existen previamente.
    """
    print("🚀 Iniciando la siembra de datos de prueba...")
    
    async with async_session_local() as session:
        async with session.begin():
            # --- Creación de Usuarios ---
            admin_user = None
            print("\n--- Creando Usuarios ---")
            for user_data in USERS_TO_CREATE:
                username = user_data["username"]
                result = await session.execute(select(User).where(User.username == username))
                existing_user = result.scalars().first()
                
                if not existing_user:
                    hashed_password = get_password_hash(user_data["password"])
                    new_user = User(username=username, hashed_password=hashed_password)
                    session.add(new_user)
                    print(f"✅ Usuario '{username}' preparado para ser creado.")
                    if username == ADMIN_USERNAME:
                        await session.flush() # Hacemos flush para obtener el ID del admin
                        admin_user = new_user
                else:
                    print(f"👍 Usuario '{username}' ya existe.")
                    if username == ADMIN_USERNAME:
                        admin_user = existing_user

            # --- Creación de Rifa de Prueba ---
            print("\n--- Creando Rifa de Prueba ---")
            if not admin_user:
                print("❌ No se puede crear la rifa porque el usuario 'admin' no existe y no pudo ser creado.")
                return # Salimos si no tenemos un admin

            raffle_name = "Gran Rifa de Lanzamiento"
            result = await session.execute(select(Raffle).where(Raffle.name == raffle_name))
            existing_raffle = result.scalars().first()

            if not existing_raffle:
                while True:
                    short_id = generate_short_id()
                    result = await session.execute(select(Raffle).where(Raffle.short_id == short_id))
                    if result.scalars().first() is None:
                        break
                
                new_raffle = Raffle(
                    id=str(uuid.uuid4()),
                    short_id=short_id,
                    name=raffle_name,
                    description="Participa en nuestra primera gran rifa y gana premios increíbles.",
                    status="active",
                    end_date=datetime.now(timezone.utc) + timedelta(days=30),
                    price=5000.0,
                    dijits_per_number=4,
                    numbers_per_ticket=1,
                    excluded_numbers=[],
                    owner_id=admin_user.id
                )
                session.add(new_raffle)
                print(f"✅ Rifa '{raffle_name}' preparada para ser creada.")
            else:
                print(f"👍 La rifa '{raffle_name}' ya existe.")
                
    print("\n🎉 Proceso de siembra de datos finalizado.")

if __name__ == "__main__":
    try:
        asyncio.run(seed_database())
    except Exception as e:
        print(f"Ocurrió un error durante la siembra de datos: {e}")
</file>

<file path="erp-backend/app/modules/raffles/Dockerfile">
# raffle-backend/Dockerfile (VERSIÓN FINAL CORREGIDA)

# --- ETAPA 1: BUILDER ---
FROM python:3.11-slim AS builder

WORKDIR /app
RUN pip install poetry
ENV POETRY_VIRTUALENVS_CREATE=false
COPY pyproject.toml poetry.lock ./
RUN poetry install --without dev --no-root


# --- ETAPA 2: PRODUCCIÓN ---
FROM python:3.11-slim

WORKDIR /app
RUN pip install poetry
ENV POETRY_VIRTUALENVS_CREATE=false

# Se copian las dependencias y los ejecutables
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# ---- ¡LA CORRECCIÓN ESTÁ AQUÍ! ----
# Se copia la carpeta de assets DESDE la ubicación correcta (dentro de 'app').
COPY ./app/assets ./app/assets/

# Se copia el código fuente de la aplicación.
COPY ./app ./app/
COPY ./main.py .
COPY ./create_first_user.py .

EXPOSE 8000

# Se llama a 'gunicorn' directamente.
CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "main:app", "--bind", "0.0.0.0:8000"]
</file>

<file path="erp-backend/app/modules/raffles/main.py">
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
from typing import List, Optional, Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi.middleware.cors import CORSMiddleware
from app.core.config import settings
from app.db.database import engine
from app.db.base import Base 
import app.db.models as models
from app.api.v1 import router as api_router
from fastapi.staticfiles import StaticFiles
import os
from app.modules.raffles.app.api.v1.uploads import router as uploads_router

app = FastAPI(title=settings.PROJECT_NAME)



# Asegúrate de que la carpeta 'uploads' exista en la raíz de 'raffle-backend'
os.makedirs("uploads", exist_ok=True)
app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")

# Evento de startup para crear tablas
@app.on_event("startup")
async def startup_event():
    async with engine.begin() as conn:
        # Esto imprimirá el SQL que se ejecutará
        print("Dropping and recreating tables...")
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all, checkfirst=True)
    print("Database tables created")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    # Allow requests from the frontend
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],  # Allow all HTTP methods
    allow_headers=["*"],  # Allow all headers
)

# Include the API router
app.include_router(api_router)
app.include_router(uploads_router, prefix="/api/v1") # Añade el prefijo de la API

def main():
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


if __name__ == "__main__":
    main()


# class Participant(BaseModel):
#     name: str
#     phone: str
#     numbers: List[str]


# class VerifyRequest(BaseModel):
#     number: str


# @app.get("/api/raffles")
# def get_raffles():
#     # Logic to fetch raffles from CSV or database
#     return {
#         "raffles": [
#             {
#                 "id": 1,
#                 "name": "Rifa 1",
#                 "description": "Rifa 1 description",
#                 "status": "active",
#             },
#             {
#                 "id": 2,
#                 "name": "Rifa 2",
#                 "description": "Rifa 2 description",
#                 "status": "active",
#             },
#             {
#                 "id": 3,
#                 "name": "Rifa 3",
#                 "description": "Rifa 3 description",
#                 "status": "active",
#             },
#         ]
#     }


# @app.post("/api/raffles/register")
# def register_participant(participant: Participant):
#     # Logic to register a participant
#     return {"success": True, "message": "Registration completed successfully"}


# @app.post("/api/raffles/verify")
# def verify_number(request: VerifyRequest):
    # Logic to verify a number
    # return {
    #     "success": True,
    #     "message": "Number verified successfully",
    #     "additional_numbers": [],
    # }
</file>

<file path="erp-backend/app/modules/raffles/package.json">
{
  "dependencies": {
    "react-slick": "^0.30.3",
    "slick-carousel": "^1.8.1"
  }
}
</file>

<file path="erp-backend/app/modules/raffles/pyproject.toml">
[project]
name = "raffle-backend"
version = "1.0.0"
description = "Service for Jungle One's raffles . Welcome tho the Jungle!"
authors = [
    {name = "Jungle One S.A.S.",email = "jungleone.team@gmail.com"}
]
license = {text = "MIT"}
readme = "../README.md"
requires-python = ">=3.10"
dependencies = [
    "fastapi (>=0.115.12,<0.116.0)",
    "uvicorn (>=0.34.2,<0.35.0)",
    "gunicorn (>=22.0.0,<23.0.0)",
    "pydantic (>=2.11.3,<3.0.0)",
    "python-dotenv (>=1.1.0,<2.0.0)",
    "pydantic-settings (>=2.9.1,<3.0.0)",
    # CAMBIO 1: Se modifica 'passlib' para usar un formato más explícito.
    "passlib[bcrypt]>=1.7.4,<2.0.0",
    # CAMBIO 2: Se añade y fija la versión de 'bcrypt' para asegurar la compatibilidad.
    "bcrypt==3.2.2",
    "python-jose[cryptography] (>=3.4.0,<4.0.0)",
    "python-multipart (>=0.0.20,<0.0.21)",
    "aiohttp (>=3.11.15)",
    "pillow (>=11.2.1,<12.0.0)",
    "sqlalchemy (>=2.0.41,<3.0.0)",
    "psycopg2-binary (>=2.9.10,<3.0.0)",
    "asyncpg (>=0.30.0,<0.31.0)"
]

[tool.poetry]
package-mode = false  # Explicitly disable packaging

[tool.poetry.group.dev.dependencies]
pytest = "^8.3.5"

[build-system]
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.poetry.scripts]
start = "app.main:main"  # Makes `poetry run start` work
</file>

<file path="erp-backend/app/modules/raffles/requirements.txt">
aiohttp
asyncpg
bcrypt==3.2.2
fastapi
passlib[bcrypt]
pillow
psycopg2-binary
pydantic
pydantic-settings
python-dotenv
python-jose[cryptography]
python-multipart
sqlalchemy
uvicorn
</file>

<file path="erp-backend/app/modules/raffles/scripts/start.sh">
#!/bin/bash
# scripts/start.sh
poetry run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
</file>

<file path="erp-backend/app/modules/users/api.py">
from fastapi import APIRouter

router = APIRouter()

# Add user-related endpoints here
</file>

<file path="erp-backend/app/modules/users/models.py">
from sqlalchemy import Column, Integer, String, Boolean
from app.core.db import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
</file>

<file path="erp-backend/app/modules/users/schemas.py">

</file>

<file path="erp-backend/app/modules/users/services.py">

</file>

<file path="erp-backend/Dockerfile">
# erp-backend/Dockerfile (VERSIÓN DE ORO - FINAL)

# --- ETAPA 1: BUILDER ---
FROM python:3.11-slim AS builder

WORKDIR /app

# Instala Poetry y configura el entorno
RUN pip install poetry
ENV POETRY_VIRTUALENVS_CREATE=false

# Copia los archivos de dependencias e instala los paquetes
COPY pyproject.toml poetry.lock ./
RUN poetry install --without dev --no-root


# --- ETAPA 2: PRODUCCIÓN ---
FROM python:3.11-slim

WORKDIR /app

# Se copian las dependencias y los ejecutables desde la etapa "builder"
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# Se copia la carpeta de assets que contiene las imágenes y fuentes
COPY ./app/assets ./app/assets/

# Se copia el código fuente de la aplicación
COPY ./app ./app/
COPY ./main.py .
COPY ./create_first_user.py .

EXPOSE 8000

# Se llama a 'gunicorn' directamente
CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "main:app", "--bind", "0.0.0.0:8000"]
</file>

<file path="erp-backend/pyproject.toml">
[tool.poetry]
name = "erp-backend"
version = "0.1.0"
description = "Backend for the ERP System"
authors = ["César A. Arango <ceau.0612@gmail.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.11"
fastapi = ">=0.115.12,<0.116.0"
uvicorn = {extras = ["standard"], version = ">=0.34.2,<0.35.0"}
pydantic = {extras = ["email"], version = ">=2.11.3,<3.0.0"}
sqlalchemy = ">=2.0.31,<3.0.0"
python-jose = {extras = ["cryptography"], version = ">=3.3.0,<4.0.0"}
passlib = {extras = ["bcrypt"], version = ">=1.7.4,<2.0.0"}
python-multipart = ">=0.0.9,<0.0.10"
asyncpg = ">=0.29.0,<0.30.0"
gunicorn = ">=22.0.0,<23.0.0"
alembic = ">=1.13.2,<2.0.0"
pydantic-settings = ">=2.4.0,<3.0.0"
pillow = ">=10.5.0,<11.0.0"
pytz = ">=2024.1,<2025.0"
python-dateutil = ">=2.9.0,<3.0.0"
greenlet = ">=3.0.3,<4.0.0"


[tool.poetry.group.dev.dependencies]
pytest = "^8.3.5"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
</file>

<file path="erp-frontend/.dockerignore">
node_modules
npm-debug.log
.env
.git

# build output
build
dist
</file>

<file path="erp-frontend/.gitignore">
node_modules/
dist/
</file>

<file path="erp-frontend/Dockerfile">
# Development Dockerfile for React frontend (Vite)
FROM node:18-alpine

WORKDIR /app

ARG VITE_API_BASE_URL
ENV VITE_API_BASE_URL=$VITE_API_BASE_URL

COPY package.json package-lock.json* ./
RUN npm install

COPY . .

EXPOSE 3000
CMD ["npm", "start"]
</file>

<file path="erp-frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ERP Frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="erp-frontend/src/App.jsx">
import React from 'react';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from './core/contexts/AuthContext';
import AppRoutes from './routes';

const App = () => (
  <BrowserRouter>
    <AuthProvider>
      <AppRoutes />
    </AuthProvider>
  </BrowserRouter>
);

export default App;
</file>

<file path="erp-frontend/src/core/components/layout/MainLayout.jsx">
// PATH: erp-frontend/src/core/components/layout/MainLayout.jsx
import * as React from 'react';
import { styled } from '@mui/material/styles';
import {
  AppBar,
  Avatar,
  Badge,
  Box,
  CssBaseline,
  Divider,
  Drawer as MuiDrawer,
  IconButton,
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Tooltip,
  Typography,
} from '@mui/material';
import MenuRoundedIcon from '@mui/icons-material/MenuRounded';
import NotificationsNoneRoundedIcon from '@mui/icons-material/NotificationsNoneRounded';
import Brightness4RoundedIcon from '@mui/icons-material/Brightness4Rounded';
import Brightness7RoundedIcon from '@mui/icons-material/Brightness7Rounded';
import { NavLink, Outlet, useLocation, useNavigate } from 'react-router-dom';
import { getMenuForRole } from '../../navigation/menuConfig';
import { useThemeMode } from '../../contexts/ThemeModeContext';
import AuthContext from '../../contexts/AuthContext';

const drawerWidth = 264;
const collapsedWidth = 80;

const Drawer = styled(MuiDrawer, {
  shouldForwardProp: (prop) => prop !== 'open',
})(({ theme, open }) => ({
  width: open ? drawerWidth : collapsedWidth,
  flexShrink: 0,
  whiteSpace: 'nowrap',
  boxSizing: 'border-box',
  '& .MuiDrawer-paper': {
    width: open ? drawerWidth : collapsedWidth,
    borderRight: `1px solid ${theme.palette.divider}`,
    overflowX: 'hidden',
    transition: theme.transitions.create('width', {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.shorter,
    }),
    // SIN bordes redondeados (requisito):
    borderRadius: 0,
  },
}));

export default function MainLayout() {
  const { mode, toggleMode } = useThemeMode();
  const { user } = React.useContext(AuthContext) || {};
  const location = useLocation();
  const navigate = useNavigate();

  const [open, setOpen] = React.useState(true);
  const menu = React.useMemo(() => getMenuForRole(user?.role || 'admin'), [user]);

  const handleToggleDrawer = () => setOpen((v) => !v);

  return (
    <Box sx={{ display: 'flex', minHeight: '100dvh' }}>
      <CssBaseline />

      {/* Header */}
      <AppBar
        position="fixed"
        color="default"
        elevation={0}
        sx={{
          backgroundColor: (t) => t.palette.background.paper,
          borderBottom: (t) => `1px solid ${t.palette.divider}`,
          // sombra sutil bajo el header
          boxShadow: (t) =>
            t.palette.mode === 'light'
              ? '0 1px 0 rgba(15, 23, 42, 0.06)'
              : '0 1px 0 rgba(0,0,0,0.4)',
          zIndex: (t) => t.zIndex.drawer + 1,
        }}
      >
        <Toolbar
          sx={{
            // 🔧 clave: forzar color de texto/íconos que heredan
            color: 'text.primary',
            gap: 1,
          }}
        >
          <IconButton onClick={handleToggleDrawer} edge="start" color="inherit">
            <MenuRoundedIcon />
          </IconButton>

          <Typography variant="h6" noWrap sx={{ ml: 1, flexGrow: 1 }}>
            ERP Admin
          </Typography>

          <Tooltip title={mode === 'dark' ? 'Light mode' : 'Dark mode'}>
            <IconButton color="inherit" onClick={toggleMode}>
              {mode === 'dark' ? <Brightness7RoundedIcon /> : <Brightness4RoundedIcon />}
            </IconButton>
          </Tooltip>

          <Tooltip title="Notificaciones">
            <IconButton color="inherit">
              <Badge color="error" variant="dot">
                <NotificationsNoneRoundedIcon />
              </Badge>
            </IconButton>
          </Tooltip>

          <Avatar
            sx={{
              width: 32,
              height: 32,
              ml: 1,
              border: (t) => `1px solid ${t.palette.divider}`,
            }}
          >
            {/* Simulación de foto de perfil */}
            {user?.name?.[0]?.toUpperCase() || 'A'}
          </Avatar>
        </Toolbar>
      </AppBar>

      {/* Sidebar */}
      <Drawer variant="permanent" open={open}>
        <Toolbar />
        <Divider />
        <List sx={{ py: 1 }}>
          {menu.map((item) => {
            const ActiveIcon = item.icon;
            const active = location.pathname.startsWith(item.path);
            return (
              <ListItemButton
                key={item.id}
                component={NavLink}
                to={item.path}
                selected={active}
                onClick={(e) => {
                  e.preventDefault();
                  navigate(item.path);
                }}
                sx={{
                  mx: 1,
                  my: 0.5,
                  borderRadius: 2,
                }}
              >
                <ListItemIcon sx={{ minWidth: 40 }}>
                  <ActiveIcon color={active ? 'primary' : 'inherit'} />
                </ListItemIcon>
                <ListItemText
                  primary={item.label}
                  primaryTypographyProps={{ fontWeight: active ? 700 : 500 }}
                  sx={{ opacity: open ? 1 : 0, transition: 'opacity .2s' }}
                />
              </ListItemButton>
            );
          })}
        </List>
      </Drawer>

      {/* Contenido */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          minWidth: 0,
          backgroundColor: (t) =>
            t.palette.mode === 'light' ? t.palette.grey[50] : t.palette.background.default,
        }}
      >
        <Toolbar />
        <Box component="div" sx={{ p: 3 }}>
          <Outlet />
        </Box>
      </Box>
    </Box>
  );
}
</file>

<file path="erp-frontend/src/core/components/ui/KpiCard.jsx">
// =============================================
// 3) src/core/components/ui/KpiCard.jsx
// =============================================
import * as React from 'react';
import { Card, CardContent, Stack, Typography, Avatar, Chip } from '@mui/material';

export default function KpiCard({ icon, label, value, diff, color = 'primary' }) {
  const positive = typeof diff === 'number' && diff >= 0;
  return (
    <Card>
      <CardContent>
        <Stack direction="row" alignItems="center" justifyContent="space-between" spacing={2}>
          <Stack spacing={0.5}>
            <Typography variant="overline" color="text.secondary">{label}</Typography>
            <Typography variant="h4">{value}</Typography>
            {typeof diff === 'number' && (
              <Chip size="small" label={`${positive ? '+' : ''}${diff}%`} color={positive ? 'success' : 'error'} sx={{ mt: 1, fontWeight: 600 }} />
            )}
          </Stack>
          {icon ? (
            <Avatar sx={{ bgcolor: (t) => t.palette[color].main, color: 'white', width: 48, height: 48 }}>
              {icon}
            </Avatar>
          ) : null}
        </Stack>
      </CardContent>
    </Card>
  );
}
</file>

<file path="erp-frontend/src/core/components/ui/PageHeader.jsx">
// =============================================
// 2) src/core/components/ui/PageHeader.jsx
// =============================================
import * as React from 'react';
import { Stack, Typography, Breadcrumbs, Link, Box } from '@mui/material';

export default function PageHeader({ title, subtitle, breadcrumbs, actions }) {
  return (
    <Stack spacing={2} sx={{ mb: 3 }}>
      {breadcrumbs?.length ? (
        <Breadcrumbs separator="/">
          {breadcrumbs.map((bc, i) => (
            <Link key={i} color={i === breadcrumbs.length - 1 ? 'text.primary' : 'inherit'} underline={i === breadcrumbs.length - 1 ? 'none' : 'hover'} href={bc.href || '#'}>
              {bc.label}
            </Link>
          ))}
        </Breadcrumbs>
      ) : null}

      <Stack direction={{ xs: 'column', sm: 'row' }} alignItems={{ xs: 'flex-start', sm: 'center' }} justifyContent="space-between" gap={2}>
        <Box>
          <Typography variant="h3" gutterBottom>{title}</Typography>
          {subtitle ? <Typography variant="subtitle1">{subtitle}</Typography> : null}
        </Box>
        {actions ? <Box>{actions}</Box> : null}
      </Stack>
    </Stack>
  );
}
</file>

<file path="erp-frontend/src/core/contexts/AuthContext.jsx">
// PATH: erp-frontend/src/core/contexts/AuthContext.jsx
import React, { createContext, useContext, useMemo, useState } from 'react';
import { ROLES } from '../navigation/menuConfig';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(() => {
    try { return JSON.parse(localStorage.getItem('user')) || null; }
    catch { return null; }
  });

  const login = async (email, password) => {
    // TODO: reemplazar por llamada real a backend
    if (email === 'admin@example.com' && password === 'password') {
      const u = { email, role: ROLES.ADMIN, token: 'demo-token' };
      setUser(u);
      localStorage.setItem('user', JSON.stringify(u));
      return u;
    }
    throw new Error('Credenciales inválidas');
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
  };

  const hasRole = (roles) => {
    if (!user) return false;
    if (!Array.isArray(roles) || roles.length === 0) return true;
    return roles.includes(user.role);
  };

  const value = useMemo(() => ({
    user,
    isAuthenticated: !!user,
    login,
    logout,
    hasRole,
  }), [user]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export const useAuth = () => useContext(AuthContext);
export default AuthContext;
</file>

<file path="erp-frontend/src/modules/admin/components/SubscriberTable.jsx">
import React from 'react';
import { Table, TableHead, TableBody, TableRow, TableCell } from '@mui/material';

const SubscriberTable = ({ data }) => (
  <Table>
    <TableHead>
      <TableRow>
        <TableCell>Nombre</TableCell>
        <TableCell>Tipo</TableCell>
        <TableCell>Estado</TableCell>
      </TableRow>
    </TableHead>
    <TableBody>
      {data.map((subscriber) => (
        <TableRow key={subscriber.id}>
          <TableCell>{subscriber.name}</TableCell>
          <TableCell>{subscriber.type}</TableCell>
          <TableCell>{subscriber.status}</TableCell>
        </TableRow>
      ))}
    </TableBody>
  </Table>
);

export default SubscriberTable;
</file>

<file path="erp-frontend/src/modules/admin/pages/SubscriberListPage.jsx">
// PATH: erp-frontend/src/modules/admin/pages/SubscriberListPage.jsx
import * as React from 'react';
import {
  Button,
  Container,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  MenuItem,
  Paper,
  Stack,
  TextField,
} from '@mui/material';
import PageHeader from '../../../core/components/ui/PageHeader';
import SubscriberTable from '../components/SubscriberTable';

// Datos de prueba
const seed = [
  { id: 1, name: 'Luis Pérez',  email: 'luis@acme.co',  plan: 'Pro',        status: 'Activo' },
  { id: 2, name: 'María Rojas', email: 'maria@acme.co', plan: 'Free',       status: 'Pendiente' },
  { id: 3, name: 'Carlos Díaz', email: 'carlos@acme.co',plan: 'Pro',        status: 'Suspendido' },
  { id: 4, name: 'Ana Torres',  email: 'ana@acme.co',   plan: 'Enterprise', status: 'Activo' },
];

export default function SubscriberListPage() {
  const [rows, setRows] = React.useState(seed); // siempre array
  const [open, setOpen] = React.useState(false);
  const [editing, setEditing] = React.useState(null);
  const [form, setForm] = React.useState({ name: '', email: '', plan: 'Free', status: 'Pendiente' });

  const showCreate = () => {
    setEditing(null);
    setForm({ name: '', email: '', plan: 'Free', status: 'Pendiente' });
    setOpen(true);
  };

  const showEdit = (row) => {
    setEditing(row);
    setForm({ name: row.name ?? '', email: row.email ?? '', plan: row.plan ?? 'Free', status: row.status ?? 'Pendiente' });
    setOpen(true);
  };

  const handleDelete = (row) => setRows((prev) => prev.filter((r) => r.id !== row.id));

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!form.name || !form.email) {
      alert('Nombre y correo son obligatorios.');
      return;
    }
    if (editing) {
      setRows((prev) => prev.map((r) => (r.id === editing.id ? { ...editing, ...form } : r)));
    } else {
      const newId = Math.max(0, ...rows.map((r) => r.id)) + 1;
      setRows((prev) => [{ id: newId, ...form }, ...prev]);
    }
    setOpen(false);
  };

  return (
    <Container maxWidth="lg" sx={{ py: 3 }}>
      <PageHeader
        title="Suscriptores"
        subtitle="Gestión de suscriptores del ERP"
        breadcrumbs={[{ label: 'Inicio', href: '/' }, { label: 'Suscriptores' }]}
        actions={<Button variant="contained" onClick={showCreate}>Nuevo</Button>}
      />

      <Paper sx={{ p: 2 }}>
        {/* rows SIEMPRE definido */}
        <SubscriberTable rows={rows} onAdd={showCreate} onEdit={showEdit} onDelete={handleDelete} />
      </Paper>

      <Dialog open={open} onClose={() => setOpen(false)} fullWidth maxWidth="sm" component="form" onSubmit={handleSubmit}>
        <DialogTitle>{editing ? 'Editar suscriptor' : 'Nuevo suscriptor'}</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <TextField
              label="Nombre"
              value={form.name}
              onChange={(e) => setForm((f) => ({ ...f, name: e.target.value }))}
              required autoFocus
            />
            <TextField
              label="Correo"
              type="email"
              value={form.email}
              onChange={(e) => setForm((f) => ({ ...f, email: e.target.value }))}
              required
            />
            <TextField select label="Plan" value={form.plan} onChange={(e) => setForm((f) => ({ ...f, plan: e.target.value }))}>
              {['Free', 'Pro', 'Enterprise'].map((opt) => (<MenuItem key={opt} value={opt}>{opt}</MenuItem>))}
            </TextField>
            <TextField select label="Estado" value={form.status} onChange={(e) => setForm((f) => ({ ...f, status: e.target.value }))}>
              {['Activo', 'Pendiente', 'Suspendido'].map((opt) => (<MenuItem key={opt} value={opt}>{opt}</MenuItem>))}
            </TextField>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>Cancelar</Button>
          <Button type="submit" variant="contained">Guardar</Button>
        </DialogActions>
      </Dialog>
    </Container>
  );
}
</file>

<file path="erp-frontend/src/modules/dashboard/pages/Dashboard.jsx">
// PATH: erp-frontend/src/modules/dashboard/pages/Dashboard.jsx
import * as React from 'react';
import { Box, Container, Paper, Button } from '@mui/material';
import Grid from '@mui/material/Grid'; // ✅ v7: Grid estable (no Grid2)
import InsightsIcon from '@mui/icons-material/Insights';
import PeopleAltIcon from '@mui/icons-material/PeopleAlt';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import MonetizationOnIcon from '@mui/icons-material/MonetizationOn';
import PageHeader from '../../../core/components/ui/PageHeader';
import KpiCard from '../../../core/components/ui/KpiCard';
import { DataGrid } from '@mui/x-data-grid';
import { LineChart } from '@mui/x-charts/LineChart';

// Medimos el ancho del contenedor para el LineChart (evita error de width)
function useContainerWidth() {
  const ref = React.useRef(null);
  const [width, setWidth] = React.useState(0);
  React.useLayoutEffect(() => {
    if (!ref.current) return;
    const ro = new ResizeObserver((entries) => {
      for (const e of entries) setWidth(Math.floor(e.contentRect.width));
    });
    ro.observe(ref.current);
    return () => ro.disconnect();
  }, []);
  return [ref, width];
}

const rows = [
  { id: 1, name: 'Luis Pérez', email: 'luis@acme.co', plan: 'Pro', status: 'Activo' },
  { id: 2, name: 'María Rojas', email: 'maria@acme.co', plan: 'Free', status: 'Pendiente' },
  { id: 3, name: 'Carlos Díaz', email: 'carlos@acme.co', plan: 'Pro', status: 'Suspendido' },
  { id: 4, name: 'Ana Torres',  email: 'ana@acme.co',   plan: 'Enterprise', status: 'Activo' },
];

const columns = [
  { field: 'name', headerName: 'Nombre', flex: 1, minWidth: 160 },
  { field: 'email', headerName: 'Correo', flex: 1, minWidth: 200 },
  { field: 'plan', headerName: 'Plan', width: 140 },
  { field: 'status', headerName: 'Estado', width: 140 },
];

export default function Dashboard() {
  const [chartRef, chartWidth] = useContainerWidth();

  return (
    <Container maxWidth="lg" sx={{ py: 3 }}>
      <PageHeader
        title="Dashboard"
        subtitle="Resumen de métricas y actividad reciente"
        breadcrumbs={[{ label: 'Inicio', href: '/' }, { label: 'Dashboard' }]}
        actions={<Button variant="contained" startIcon={<InsightsIcon/>}>Nuevo reporte</Button>}
      />

      <Grid container spacing={2}>
        <Grid item xs={12} md={3}>
          <KpiCard label="Ingresos" value="$84,2M" diff={12} icon={<MonetizationOnIcon/>} color="success" />
        </Grid>
        <Grid item xs={12} md={3}>
          <KpiCard label="Clientes" value="1.248" diff={4} icon={<PeopleAltIcon/>} />
        </Grid>
        <Grid item xs={12} md={3}>
          <KpiCard label="Órdenes" value="3.902" diff={-2} icon={<ReceiptLongIcon/>} color="secondary" />
        </Grid>
        <Grid item xs={12} md={3}>
          <KpiCard label="ARPU" value="$67.3" diff={1.3} icon={<InsightsIcon/>} color="info" />
        </Grid>

        <Grid item xs={12} md={7}>
          <Paper sx={{ p: 2 }}>
            <Box ref={chartRef} sx={{ width: '100%' }}>
              <LineChart
                width={chartWidth || 600}
                height={320}
                xAxis={[{ data: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul'] }]}
                series={[{ data: [22, 28, 26, 32, 38, 36, 44], label: 'Ingresos' }]}
                grid={{ horizontal: true }}
              />
            </Box>
          </Paper>
        </Grid>

        <Grid item xs={12} md={5}>
          <Paper sx={{ p: 2, height: 360 }}>
            <DataGrid
              rows={rows}
              columns={columns}
              disableRowSelectionOnClick
              pageSizeOptions={[5]}
              initialState={{ pagination: { paginationModel: { pageSize: 5 } } }}
              sx={{ border: 'none', height: '100%' }}
            />
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
}
</file>

<file path="erp-frontend/src/routes/index.jsx">
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import MainLayout from '../core/components/layout/MainLayout';
import ProtectedRoute from './ProtectedRoute';
import LoginPage from '../modules/auth/pages/LoginPage';
import Dashboard from '../modules/dashboard/pages/Dashboard';
import SubscriberListPage from '../modules/admin/pages/SubscriberListPage';

export default function AppRoutes() {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />

      <Route element={<ProtectedRoute />}>
        <Route element={<MainLayout />}>
          <Route index element={<Navigate to="/dashboard" replace />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/subscribers" element={<SubscriberListPage />} />
        </Route>
      </Route>

      <Route path="*" element={<Navigate to="/dashboard" replace />} />
    </Routes>
  );
}
</file>

<file path="erp-frontend/src/routes/ProtectedRoute.jsx">
import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../core/contexts/AuthContext';

export default function ProtectedRoute() {
  const { isAuthenticated } = useAuth();
  return isAuthenticated ? <Outlet /> : <Navigate to="/login" replace />;
}
</file>

<file path="erp-frontend/src/theme/index.js">
// PATH: erp-frontend/src/theme/index.js
export { getAppTheme } from './theme';
</file>

<file path="erp-frontend/src/theme/theme.js">
// PATH: erp-frontend/src/theme/theme.js
import { createTheme } from '@mui/material/styles';

const baseTypography = {
  fontFamily: `'InterVariable', 'Inter var', Inter, Roboto, system-ui, -apple-system, 'Segoe UI', Arial, sans-serif`,
  h1: { fontSize: 36, fontWeight: 800, letterSpacing: -0.5, lineHeight: 1.2 },
  h2: { fontSize: 30, fontWeight: 700, letterSpacing: -0.2, lineHeight: 1.25 },
  h3: { fontSize: 24, fontWeight: 700, lineHeight: 1.3 },
  h4: { fontSize: 20, fontWeight: 700, lineHeight: 1.35 },
  h5: { fontSize: 18, fontWeight: 600 },
  h6: { fontSize: 16, fontWeight: 600 },
  subtitle1: { fontSize: 15, lineHeight: 1.5 },
  body1: { fontSize: 14, lineHeight: 1.6 },
  body2: { fontSize: 13, lineHeight: 1.6 },
  button: { textTransform: 'none', fontWeight: 600, letterSpacing: 0 },
  caption: { fontSize: 12 },
  overline: { fontSize: 11, letterSpacing: 1, textTransform: 'uppercase' },
};

const tokens = {
  dark: {
    palette: {
      mode: 'dark',
      primary:   { main: '#22C55E', contrastText: '#0B1110' },
      secondary: { main: '#10B981' },
      success:   { main: '#22C55E' },
      info:      { main: '#2DD4BF' },
      warning:   { main: '#F59E0B' },
      error:     { main: '#EF4444' },
      background: { default: '#0B1512', paper: '#0F1F1A' },
      text: { primary: '#E6FFF3', secondary: '#9BD3B0' },
      divider: 'rgba(226, 252, 239, 0.08)',
    },
    shape: { borderRadius: 14 },
    typography: {
      ...baseTypography,
      subtitle1: { ...baseTypography.subtitle1, color: '#9BD3B0' },
      body2: { ...baseTypography.body2, color: '#9BD3B0' },
      caption: { ...baseTypography.caption, color: '#8EBFA6' },
    },
    components: {
      MuiCssBaseline: {
        styleOverrides: {
          html: { scrollBehavior: 'smooth' },
          body: {
            backgroundColor: '#0B1512',
            backgroundImage:
              'radial-gradient(1200px 600px at -10% -10%, rgba(34,197,94,0.08), transparent 40%), radial-gradient(800px 400px at 110% -10%, rgba(16,185,129,0.08), transparent 40%)',
          },
          '*::-webkit-scrollbar': { width: 10, height: 10 },
          '*::-webkit-scrollbar-thumb': { background: '#274034', borderRadius: 8 },
        },
      },
      MuiAppBar: {
        styleOverrides: {
          root: {
            borderRadius: 0,
            backgroundImage: 'none',
            backgroundColor: '#0F1F1A',
            color: '#E6FFF3', // fuerza color de texto/iconos en dark
            boxShadow: '0 6px 18px rgba(0,0,0,0.45)',
            borderBottom: '1px solid rgba(226,252,239,0.06)',
          },
        },
      },
      MuiPaper: {
        defaultProps: { elevation: 0 },
        styleOverrides: {
          root: {
            borderRadius: 14,
            border: '1px solid rgba(226,252,239,0.06)',
            backgroundImage:
              'linear-gradient(180deg, rgba(34,197,94,0.06), rgba(34,197,94,0.01))',
          },
        },
      },
      MuiButton: {
        defaultProps: { disableElevation: true },
        styleOverrides: {
          root: { borderRadius: 999, paddingInline: 16 },
          containedPrimary: { color: '#0B1110' },
        },
      },
      MuiTableHead: {
        styleOverrides: {
          root: { '& th': { fontWeight: 700, background: 'rgba(34,197,94,0.08)' } },
        },
      },
    },
  },

  light: {
    palette: {
      mode: 'light',
      primary:   { main: '#16A34A', contrastText: '#ffffff' },
      secondary: { main: '#059669' },
      success:   { main: '#16A34A' },
      info:      { main: '#0EA5E9' },
      warning:   { main: '#F59E0B' },
      error:     { main: '#DC2626' },
      background: { default: '#F5FBF7', paper: '#FFFFFF' },
      text: { primary: '#0B1110', secondary: '#4B6B58' },
      divider: '#E2E8F0',
    },
    shape: { borderRadius: 14 },
    typography: {
      ...baseTypography,
      subtitle1: { ...baseTypography.subtitle1, color: '#4B6B58' },
      body2: { ...baseTypography.body2, color: '#4B6B58' },
      caption: { ...baseTypography.caption, color: '#6E9380' },
    },
    components: {
      MuiCssBaseline: {
        styleOverrides: {
          html: { scrollBehavior: 'smooth' },
          body: {
            backgroundColor: '#F5FBF7',
            backgroundImage:
              'radial-gradient(1200px 600px at -10% -10%, rgba(22,163,74,0.08), transparent 40%), radial-gradient(800px 400px at 110% -10%, rgba(5,150,105,0.08), transparent 40%)',
          },
          '*::-webkit-scrollbar': { width: 10, height: 10 },
          '*::-webkit-scrollbar-thumb': { background: '#CDE7D6', borderRadius: 8 },
        },
      },
      MuiAppBar: {
        styleOverrides: {
          root: {
            borderRadius: 0,
            backgroundImage: 'none',
            backgroundColor: '#FFFFFF',
            color: '#0B1110', // fuerza color de texto/iconos en light
            boxShadow: '0 8px 24px rgba(2, 42, 22, 0.08)',
            borderBottom: '1px solid #E2E8F0',
          },
        },
      },
      MuiPaper: {
        defaultProps: { elevation: 0 },
        styleOverrides: {
          root: {
            borderRadius: 14,
            border: '1px solid #E2E8F0',
            backgroundImage:
              'linear-gradient(180deg, rgba(22,163,74,0.03), rgba(22,163,74,0.01))',
          },
        },
      },
      MuiButton: {
        defaultProps: { disableElevation: true },
        styleOverrides: {
          root: { borderRadius: 999, paddingInline: 16 },
          containedPrimary: { color: '#ffffff' },
        },
      },
      MuiTableHead: {
        styleOverrides: {
          root: { '& th': { fontWeight: 700, background: '#ECFDF5' } },
        },
      },
    },
  },
};

export function getAppTheme(mode = 'dark') {
  const cfg = tokens[mode] ?? tokens.dark;
  return createTheme({
    palette: cfg.palette,
    shape: cfg.shape,
    typography: cfg.typography,
    components: cfg.components,
  });
}
</file>

<file path="erp-frontend/vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
});
</file>

<file path="docker-compose.yml">
services:
  db:
    image: postgres:15-alpine
    container_name: erp_db
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=1234
      - POSTGRES_DB=erp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    container_name: erp_backend
    build:
      context: ./erp-backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:1234@db:5432/erp
    volumes:
      - ./erp-backend:/app
    depends_on:
      - db

  frontend:
    container_name: erp_frontend
    build:
      context: ./erp-frontend
      args:
        - VITE_API_BASE_URL=http://localhost:8000/api/v1
    ports:
      - "3000:3000" # puerto del servidor de desarrollo de Vite
    environment:
      - CHOKIDAR_USEPOLLING=true # hot-reload dentro de Docker
    volumes:
      - ./erp-frontend:/app
      - /app/node_modules # evita que node_modules local sobreescriba el del contenedor
    command: ["npm", "start"]

volumes:
  postgres_data:
</file>

<file path="erp-frontend/package.json">
{
  "name": "erp-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "start": "vite --host",
    "build": "vite build",
    "preview": "vite preview",
    "test": "echo \"No tests configured\" && exit 0"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@fontsource-variable/inter": "^5.2.6",
    "@mui/icons-material": "^7.3.1",
    "@mui/material": "^7.3.1",
    "@mui/x-charts": "^7.29.1",
    "@mui/x-data-grid": "^7.29.9",
    "axios": "^1.11.0",
    "final-form": "^4.20.10",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-final-form": "^6.5.9",
    "react-router-dom": "^6.22.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^5.0.0"
  }
}
</file>

<file path="erp-frontend/src/main.jsx">
// PATH: erp-frontend/src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import AppRoutes from './routes';
import { AuthProvider } from './core/contexts/AuthContext';
import { ThemeModeProvider } from './core/contexts/ThemeModeContext';
import '@fontsource-variable/inter';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <ThemeModeProvider>
      <BrowserRouter>
        <AuthProvider>
          <AppRoutes />
        </AuthProvider>
      </BrowserRouter>
    </ThemeModeProvider>
  </React.StrictMode>
);
</file>

<file path="erp-frontend/src/modules/auth/pages/LoginPage.jsx">
// =============================================
// 4) src/modules/auth/pages/LoginPage.jsx
// =============================================
import * as React from 'react';
import { useState } from 'react';
import {
  Avatar, Box, Button, Checkbox, Container, FormControlLabel,
  InputAdornment, Link, Paper, Stack, TextField, Typography
} from '@mui/material';
import LockOutlinedIcon from '@mui/icons-material/LockOutlined';
import MailOutlineIcon from '@mui/icons-material/MailOutline';
import KeyIcon from '@mui/icons-material/Key';
import { useAuth } from '../../../core/contexts/AuthContext';
import { useNavigate } from 'react-router-dom';

export default function LoginPage() {
  const [loading, setLoading] = useState(false);
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    const data = new FormData(e.currentTarget);
    const email = data.get('email');
    const password = data.get('password');
    try {
      setLoading(true);
      await login(email, password);     // mock demo en el AuthContext
      navigate('/dashboard', { replace: true });
    } catch (err) {
      alert(err.message || 'No se pudo iniciar sesión');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs" sx={{ display: 'grid', placeItems: 'center', minHeight: '100dvh' }}>
      <Paper sx={{ p: 4, width: '100%' }}>
        <Stack alignItems="center" spacing={2} sx={{ mb: 2 }}>
          <Avatar sx={{ bgcolor: 'primary.main', width: 56, height: 56 }}>
            <LockOutlinedIcon />
          </Avatar>
          <Typography variant="h4">Iniciar sesión</Typography>
          <Typography variant="body2" color="text.secondary">Bienvenido de nuevo, ingresa tus credenciales.</Typography>
        </Stack>

        <Box component="form" onSubmit={handleSubmit} noValidate>
          <Stack spacing={2}>
            <TextField
              name="email"
              label="Correo electrónico"
              type="email"
              fullWidth
              required
              autoFocus
              InputProps={{ startAdornment: (
                <InputAdornment position="start"><MailOutlineIcon /></InputAdornment>
              ) }}
            />

            <TextField
              name="password"
              label="Contraseña"
              type="password"
              fullWidth
              required
              InputProps={{ startAdornment: (
                <InputAdornment position="start"><KeyIcon /></InputAdornment>
              ) }}
            />

            <Stack direction="row" alignItems="center" justifyContent="space-between">
              <FormControlLabel control={<Checkbox defaultChecked />} label="Recordarme" />
              <Link href="#" variant="body2">¿Olvidaste tu contraseña?</Link>
            </Stack>

            <Button type="submit" variant="contained" size="large" disabled={loading}>
              {loading ? 'Ingresando…' : 'Ingresar'}
            </Button>

            <Typography variant="caption" color="text.secondary" sx={{ textAlign: 'center' }}>
              Demo: admin@example.com / password
            </Typography>
          </Stack>
        </Box>
      </Paper>
    </Container>
  );
}
</file>

</files>
