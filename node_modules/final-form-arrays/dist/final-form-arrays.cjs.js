'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function copyField(oldFields, oldKey, newFields, newKey) {
    newFields[newKey] = {
        ...oldFields[oldKey],
        name: newKey,
        // prevent functions from being overwritten
        // if the newFields[newKey] does not exist, it will be created
        // when that field gets registered, with its own change/blur/focus callbacks
        change: oldFields[newKey] && oldFields[newKey].change,
        blur: oldFields[newKey] && oldFields[newKey].blur,
        focus: oldFields[newKey] && oldFields[newKey].focus,
        lastFieldState: undefined // clearing lastFieldState forces renotification
    };
    if (!newFields[newKey].change) {
        delete newFields[newKey].change;
    }
    if (!newFields[newKey].blur) {
        delete newFields[newKey].blur;
    }
    if (!newFields[newKey].focus) {
        delete newFields[newKey].focus;
    }
}

// From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
const escapeRegexTokens = (string) => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string

const insert = ([name, index, value], state, { changeValue }) => {
    changeValue(state, name, (array) => {
        const copy = [...(array || [])];
        copy.splice(index, 0, value);
        return copy;
    });
    // now increment any higher indices
    const pattern = new RegExp(`^${escapeRegexTokens(name)}\\[(\\d+)\\](.*)`);
    const newFields = {};
    Object.keys(state.fields).forEach(key => {
        const tokens = pattern.exec(key);
        if (tokens) {
            const fieldIndex = Number(tokens[1]);
            if (fieldIndex >= index) {
                // Shift all higher indices up
                const incrementedKey = `${name}[${fieldIndex + 1}]${tokens[2]}`;
                copyField(state.fields, key, newFields, incrementedKey);
                return;
            }
        }
        // Keep this field that does not match the name,
        // or has index smaller than what is being inserted
        newFields[key] = state.fields[key];
    });
    state.fields = newFields;
};

const concat = ([name, value], state, { changeValue }) => {
    changeValue(state, name, (array) => array ? [...array, ...value] : value);
};

const move = ([name, from, to], state, { changeValue }) => {
    if (from === to) {
        return;
    }
    changeValue(state, name, (array) => {
        const copy = [...(array || [])];
        const value = copy[from];
        copy.splice(from, 1);
        copy.splice(to, 0, value);
        return copy;
    });
    const newFields = {};
    const pattern = new RegExp(`^${escapeRegexTokens(name)}\\[(\\d+)\\](.*)`);
    let lowest;
    let highest;
    let increment;
    if (from > to) {
        lowest = to;
        highest = from;
        increment = 1;
    }
    else {
        lowest = from;
        highest = to;
        increment = -1;
    }
    Object.keys(state.fields).forEach(key => {
        const tokens = pattern.exec(key);
        if (tokens) {
            const fieldIndex = Number(tokens[1]);
            if (fieldIndex === from) {
                const newKey = `${name}[${to}]${tokens[2]}`;
                copyField(state.fields, key, newFields, newKey);
                return;
            }
            if (lowest <= fieldIndex && fieldIndex <= highest) {
                // Shift all indices
                const newKey = `${name}[${fieldIndex + increment}]${tokens[2]}`;
                copyField(state.fields, key, newFields, newKey);
                return;
            }
        }
        // Keep this field that does not match the name,
        // or has index smaller or larger than affected range
        newFields[key] = state.fields[key];
    });
    state.fields = newFields;
};

const remove = ([name, index], state, { changeValue, getIn, setIn }) => {
    let returnValue;
    changeValue(state, name, (array) => {
        if (!array) {
            return array;
        }
        const copy = [...array];
        returnValue = copy[index];
        copy.splice(index, 1);
        return copy.length > 0
            ? copy
            : undefined;
    });
    // now we have to remove any subfields for our index,
    // and decrement all higher indexes.
    const pattern = new RegExp(`^${escapeRegexTokens(name)}\\[(\\d+)\\](.*)`);
    const newFields = {};
    Object.keys(state.fields).forEach(key => {
        const tokens = pattern.exec(key);
        if (tokens) {
            const fieldIndex = Number(tokens[1]);
            if (fieldIndex === index) {
                // delete any submitErrors for this array item
                // if the root key of the delete index
                if (key === `${name}[${index}]`) {
                    const path = `formState.submitErrors.${name}`;
                    const submitErrors = getIn(state, path);
                    // if has submitErrors for array
                    if (Array.isArray(submitErrors)) {
                        submitErrors.splice(index, 1);
                        setIn(state, path, submitErrors);
                    }
                }
                return;
            }
            if (fieldIndex > index) {
                // Shift all higher indices down
                const decrementedKey = `${name}[${fieldIndex - 1}]${tokens[2]}`;
                copyField(state.fields, key, newFields, decrementedKey);
                return;
            }
        }
        // Keep this field that does not match the name,
        // or has index smaller than what is being removed
        newFields[key] = state.fields[key];
    });
    state.fields = newFields;
    return returnValue;
};

const pop = ([name], state, tools) => {
    const { getIn } = tools;
    const array = getIn(state.formState.values, name);
    return array && array.length > 0
        ? remove([name, array.length - 1], state, tools)
        : undefined;
};

const push = ([name, value], state, { changeValue }) => {
    changeValue(state, name, (array) => array ? [...array, value] : [value]);
};

const binarySearch = (list, value) => {
    // This algorithm assumes the items in list is unique
    let first = 0;
    let last = list.length - 1;
    let middle = 0;
    while (first <= last) {
        middle = Math.floor((first + last) / 2);
        if (list[middle] === value) {
            return middle;
        }
        if (list[middle] > value) {
            last = middle - 1;
        }
        else {
            first = middle + 1;
        }
    }
    return ~first;
};
const removeBatch = ([name, indexes], state, { changeValue }) => {
    if (indexes.length === 0) {
        return [];
    }
    const sortedIndexes = [...indexes];
    sortedIndexes.sort();
    // Remove duplicates
    for (let i = sortedIndexes.length - 1; i > 0; i -= 1) {
        if (sortedIndexes[i] === sortedIndexes[i - 1]) {
            sortedIndexes.splice(i, 1);
        }
    }
    let returnValue = [];
    changeValue(state, name, (array) => {
        // use original order of indexes for return value
        returnValue = indexes.map((index) => array && array[index]);
        if (!array) {
            return array;
        }
        const copy = [...array];
        for (let i = sortedIndexes.length - 1; i >= 0; i -= 1) {
            const index = sortedIndexes[i];
            copy.splice(index, 1);
        }
        return copy.length > 0
            ? copy
            : undefined;
    });
    // now we have to remove any subfields for our indexes,
    // and decrement all higher indexes.
    const pattern = new RegExp(`^${escapeRegexTokens(name)}\\[(\\d+)\\](.*)`);
    const newFields = {};
    Object.keys(state.fields).forEach(key => {
        const tokens = pattern.exec(key);
        if (tokens) {
            const fieldIndex = Number(tokens[1]);
            const indexOfFieldIndex = binarySearch(sortedIndexes, fieldIndex);
            if (indexOfFieldIndex >= 0) {
                // One of the removed indices
                return;
            }
            if (fieldIndex > sortedIndexes[0]) {
                // Shift all higher indices down
                const decrementedKey = `${name}[${fieldIndex - ~indexOfFieldIndex}]${tokens[2]}`;
                copyField(state.fields, key, newFields, decrementedKey);
                return;
            }
        }
        // Keep this field that does not match the name,
        // or has index smaller than what is being removed
        newFields[key] = state.fields[key];
    });
    state.fields = newFields;
    return returnValue;
};

const shift = ([name], state, tools) => remove([name, 0], state, tools);

const swap = ([name, indexA, indexB], state, { changeValue }) => {
    if (indexA === indexB) {
        return;
    }
    changeValue(state, name, (array) => {
        const copy = [...(array || [])];
        const a = copy[indexA];
        copy[indexA] = copy[indexB];
        copy[indexB] = a;
        return copy;
    });
    // swap all field state that begin with "name[indexA]" with that under "name[indexB]"
    const aPrefix = `${name}[${indexA}]`;
    const bPrefix = `${name}[${indexB}]`;
    const newFields = {};
    Object.keys(state.fields).forEach(key => {
        if (key.substring(0, aPrefix.length) === aPrefix) {
            const suffix = key.substring(aPrefix.length);
            const newKey = bPrefix + suffix;
            copyField(state.fields, key, newFields, newKey);
        }
        else if (key.substring(0, bPrefix.length) === bPrefix) {
            const suffix = key.substring(bPrefix.length);
            const newKey = aPrefix + suffix;
            copyField(state.fields, key, newFields, newKey);
        }
        else {
            // Keep this field that does not match the name
            newFields[key] = state.fields[key];
        }
    });
    state.fields = newFields;
};

const unshift = ([name, value], state, tools) => insert([name, 0, value], state, tools);

const update = ([name, index, value], state, { changeValue }) => {
    changeValue(state, name, (array) => {
        const copy = [...(array || [])];
        copy.splice(index, 1, value);
        return copy;
    });
};

const mutators = {
    insert,
    concat,
    move,
    pop,
    push,
    remove,
    removeBatch,
    shift,
    swap,
    unshift,
    update
};

exports.concat = concat;
exports.default = mutators;
exports.insert = insert;
exports.move = move;
exports.pop = pop;
exports.push = push;
exports.remove = remove;
exports.removeBatch = removeBatch;
exports.shift = shift;
exports.swap = swap;
exports.unshift = unshift;
exports.update = update;
